open class ManagedBuffer<Header, Element> {
    public class func create(minimumCapacity: Int, makingHeaderWith factory: (ManagedBuffer<Header, Element>) throws -> Header) rethrows -> ManagedBuffer<Header, Element> {}
    public var capacity: Int { get }
    public var header: Header { get set }
    public func withUnsafeMutablePointerToElements<R>(_ body: (UnsafeMutablePointer<Element>) throws -> R) rethrows -> R {}
    public func withUnsafeMutablePointerToHeader<R>(_ body: (UnsafeMutablePointer<Header>) throws -> R) rethrows -> R {}
    public func withUnsafeMutablePointers<R>(_ body: (UnsafeMutablePointer<Header>, UnsafeMutablePointer<Element>) throws -> R) rethrows -> R {}
}
public protocol BidirectionalCollection : Collection, Sequence {
    var last: Element? { get }
    var last: Element? { get }
    func formIndex(before i: inout Index)
    func index(before i: Index) -> Index
    func last(where predicate: (Element) throws -> Bool) rethrows -> Element?
    func lastIndex(of element: Element) -> Index? where Element : Equatable
    func lastIndex(where predicate: (Element) throws -> Bool) rethrows -> Index?
    mutating func popLast() -> Element? where Self == SubSequence
    @discardableResult mutating func removeLast() -> Element where Self == SubSequence
    mutating func removeLast(_ k: Int) where Self == SubSequence
}
public protocol BinaryFloatingPoint : Comparable, Equatable, ExpressibleByFloatLiteral, ExpressibleByIntegerLiteral, FloatingPoint, Hashable, Numeric, SignedNumeric, Strideable {
    associatedtype RawExponent
    associatedtype RawSignificand
    static var exponentBitCount: Int { get }
    static var significandBitCount: Int { get }
    static func random(in range: ClosedRange<Self>) -> Self where RawSignificand : FixedWidthInteger
    static func random<T>(in range: ClosedRange<Self>, using generator: inout T) -> Self where RawSignificand : FixedWidthInteger, T : RandomNumberGenerator
    init(sign: FloatingPointSign, exponentBitPattern: RawExponent, significandBitPattern: RawSignificand)
    var binade: Self { get }
    var exponentBitPattern: RawExponent { get }
    var significandBitPattern: RawSignificand { get }
    var significandWidth: Int { get }
}
public protocol BinaryInteger : Comparable, CustomStringConvertible, Equatable, ExpressibleByIntegerLiteral, Hashable, Numeric, Strideable {
    associatedtype Words where UInt == Words.Element
    static var isSigned: Bool { get }
    init()
    init<T>(_ source: T) where T : BinaryFloatingPoint
    init<T>(_ source: T) where T : BinaryInteger
    init<T>(clamping source: T) where T : BinaryInteger
    init<T>(truncatingIfNeeded source: T) where T : BinaryInteger
    var bitWidth: Int { get }
    var trailingZeroBitCount: Int { get }
    var words: Words { get }
    func %(lhs: Self, rhs: Self) -> Self
    func %=(lhs: inout Self, rhs: Self)
    func &(lhs: Self, rhs: Self) -> Self
    func &=(lhs: inout Self, rhs: Self)
    func /(lhs: Self, rhs: Self) -> Self
    func /=(lhs: inout Self, rhs: Self)
    func <<<RHS>(lhs: Self, rhs: RHS) -> Self where RHS : BinaryInteger
    func <<=<RHS>(lhs: inout Self, rhs: RHS) where RHS : BinaryInteger
    func >><RHS>(lhs: Self, rhs: RHS) -> Self where RHS : BinaryInteger
    func >>=<RHS>(lhs: inout Self, rhs: RHS) where RHS : BinaryInteger
    func ^(lhs: Self, rhs: Self) -> Self
    func ^=(lhs: inout Self, rhs: Self)
    func quotientAndRemainder(dividingBy rhs: Self) -> (quotient : Self, remainder : Self)
    func quotientAndRemainder(dividingBy rhs: Self) -> (quotient : Self, remainder : Self)
    func signum() -> Self
    func |(lhs: Self, rhs: Self) -> Self
    func |=(lhs: inout Self, rhs: Self)
    prefix func ~(x: Self) -> Self
}
public protocol CVarArg {
}
public protocol CaseIterable {
    associatedtype AllCases where AllCases.Element == Self
    static var allCases: AllCases { get }
}
public protocol CodingKey : CustomDebugStringConvertible, CustomStringConvertible {
    init?(intValue: Int)
    init?(stringValue: String)
    var intValue: Int? { get }
    var stringValue: String { get }
}
public protocol Collection : Sequence {
    associatedtype Index
    associatedtype Indices where Index == Indices.Element, Index == Indices.Index, Indices == Indices.SubSequence
    var count: Int { get }
    var endIndex: Index { get }
    var first: Element? { get }
    var indices: DefaultIndices<Self> { get } where DefaultIndices<Self> == Indices
    var indices: Indices { get }
    var isEmpty: Bool { get }
    var isEmpty: Bool { get }
    var startIndex: Index { get }
    subscript(bounds: Range<Index>) -> Slice<Self> { get } where Slice<Self> == SubSequence
    subscript(bounds: Range<Index>) -> SubSequence { get }
    subscript(position: Index) -> Element { get }
    subscript(x: UnboundedRange) -> SubSequence { get }
    subscript<R>(r: R) -> SubSequence { get } where R : RangeExpression, Index == R.Bound
    func distance(from start: Index, to end: Index) -> Int
    func firstIndex(of element: Element) -> Index? where Element : Equatable
    func firstIndex(where predicate: (Element) throws -> Bool) rethrows -> Index?
    func formIndex(_ i: inout Index, offsetBy distance: Int)
    func formIndex(_ i: inout Index, offsetBy distance: Int, limitedBy limit: Index) -> Bool
    func formIndex(after i: inout Index)
    func index(_ i: Index, offsetBy distance: Int) -> Index
    func index(_ i: Index, offsetBy distance: Int, limitedBy limit: Index) -> Index?
    func index(after i: Index) -> Index
    func index(of _element: Element) -> Index? where Element : Equatable
    func index(where _predicate: (Element) throws -> Bool) rethrows -> Index?
    mutating func popFirst() -> Element? where Self == SubSequence
    func prefix(through position: Index) -> SubSequence
    func prefix(upTo end: Index) -> SubSequence
    func randomElement() -> Element?
    func randomElement<T>(using generator: inout T) -> Element? where T : RandomNumberGenerator
    @discardableResult mutating func removeFirst() -> Element where Self == SubSequence
    mutating func removeFirst(_ k: Int) where Self == SubSequence
    func suffix(from start: Index) -> SubSequence
}
public protocol Comparable : Equatable {
    postfix func ...(minimum: Self) -> PartialRangeFrom<Self>
    prefix func ...(maximum: Self) -> PartialRangeThrough<Self>
    func ...(minimum: Self, maximum: Self) -> ClosedRange<Self>
    prefix func ..<(maximum: Self) -> PartialRangeUpTo<Self>
    func ..<(minimum: Self, maximum: Self) -> Range<Self>
    func <(lhs: Self, rhs: Self) -> Bool
    func <=(lhs: Self, rhs: Self) -> Bool
    func <=(lhs: Self, rhs: Self) -> Bool
    func >(lhs: Self, rhs: Self) -> Bool
    func >(lhs: Self, rhs: Self) -> Bool
    func >=(lhs: Self, rhs: Self) -> Bool
    func >=(lhs: Self, rhs: Self) -> Bool
}
public protocol CustomDebugStringConvertible {
    var debugDescription: String { get }
}
public protocol CustomLeafReflectable : CustomReflectable {
}
public protocol CustomPlaygroundDisplayConvertible {
    var playgroundDescription: Any { get }
}
public protocol CustomReflectable {
    var customMirror: Mirror { get }
}
public protocol CustomStringConvertible {
    var description: String { get }
}
public protocol Decodable {
    init(from decoder: Decoder) throws
}
public protocol Decoder {
    var codingPath: [CodingKey] { get }
    var userInfo: [CodingUserInfoKey: Any] { get }
    func container<Key>(keyedBy type: Key.Type) throws -> KeyedDecodingContainer<Key>
    func singleValueContainer() throws -> SingleValueDecodingContainer
    func unkeyedContainer() throws -> UnkeyedDecodingContainer
}
public protocol Encodable {
    func encode(to encoder: Encoder) throws
}
public protocol Encoder {
    var codingPath: [CodingKey] { get }
    var userInfo: [CodingUserInfoKey: Any] { get }
    func container<Key>(keyedBy type: Key.Type) -> KeyedEncodingContainer<Key>
    func singleValueContainer() -> SingleValueEncodingContainer
    func unkeyedContainer() -> UnkeyedEncodingContainer
}
public protocol Equatable {
    func !=(lhs: Self, rhs: Self) -> Bool
    func ==(lhs: Self, rhs: Self) -> Bool
}
public protocol Error {
}
public protocol ExpressibleByArrayLiteral {
    associatedtype ArrayLiteralElement
    init(arrayLiteral elements: ArrayLiteralElement...)
}
public protocol ExpressibleByBooleanLiteral {
    associatedtype BooleanLiteralType
    init(booleanLiteral value: BooleanLiteralType)
}
public protocol ExpressibleByDictionaryLiteral {
    associatedtype Key
    associatedtype Value
    init(dictionaryLiteral elements: (Key, Value)...)
}
public protocol ExpressibleByExtendedGraphemeClusterLiteral : ExpressibleByUnicodeScalarLiteral {
    associatedtype ExtendedGraphemeClusterLiteralType
    init(extendedGraphemeClusterLiteral value: ExtendedGraphemeClusterLiteralType)
}
public protocol ExpressibleByFloatLiteral {
    associatedtype FloatLiteralType
    init(floatLiteral value: FloatLiteralType)
}
public protocol ExpressibleByIntegerLiteral {
    associatedtype IntegerLiteralType
    init(integerLiteral value: IntegerLiteralType)
}
public protocol ExpressibleByNilLiteral {
    init(nilLiteral: Void)
}
public protocol ExpressibleByStringLiteral : ExpressibleByExtendedGraphemeClusterLiteral, ExpressibleByUnicodeScalarLiteral {
    associatedtype StringLiteralType
    init(stringLiteral value: StringLiteralType)
}
public protocol ExpressibleByUnicodeScalarLiteral {
    associatedtype UnicodeScalarLiteralType
    init(unicodeScalarLiteral value: UnicodeScalarLiteralType)
}
public protocol FixedWidthInteger : BinaryInteger, Comparable, CustomStringConvertible, Equatable, ExpressibleByIntegerLiteral, Hashable, LosslessStringConvertible, Numeric, Strideable, _BitwiseOperations {
    static var bitWidth: Int { get }
    static var max: Self { get }
    static var min: Self { get }
    static func random(in range: ClosedRange<Self>) -> Self
    static func random<T>(in range: ClosedRange<Self>, using generator: inout T) -> Self where T : RandomNumberGenerator
    init?<S>(_ text: S, radix: Int = x) where S : StringProtocol
    init(bigEndian value: Self)
    init(littleEndian value: Self)
    var bigEndian: Self { get }
    var byteSwapped: Self { get }
    var leadingZeroBitCount: Int { get }
    var littleEndian: Self { get }
    var nonzeroBitCount: Int { get }
    func &*(lhs: Self, rhs: Self) -> Self
    func &*=(lhs: inout Self, rhs: Self)
    func &+(lhs: Self, rhs: Self) -> Self
    func &+=(lhs: inout Self, rhs: Self)
    func &-(lhs: Self, rhs: Self) -> Self
    func &-=(lhs: inout Self, rhs: Self)
    func &<<(lhs: Self, rhs: Self) -> Self
    func &<<=(lhs: inout Self, rhs: Self)
    func &>>(lhs: Self, rhs: Self) -> Self
    func &>>=(lhs: inout Self, rhs: Self)
    func addingReportingOverflow(_ rhs: Self) -> (partialValue : Self, overflow : Bool)
    func dividedReportingOverflow(by rhs: Self) -> (partialValue : Self, overflow : Bool)
    func dividingFullWidth(_ dividend: (high : Self, low : Magnitude)) -> (quotient : Self, remainder : Self)
    func multipliedFullWidth(by other: Self) -> (high : Self, low : Magnitude)
    func multipliedReportingOverflow(by rhs: Self) -> (partialValue : Self, overflow : Bool)
    func remainderReportingOverflow(dividingBy rhs: Self) -> (partialValue : Self, overflow : Bool)
    func subtractingReportingOverflow(_ rhs: Self) -> (partialValue : Self, overflow : Bool)
}
public protocol FloatingPoint : Comparable, Equatable, ExpressibleByIntegerLiteral, Hashable, Numeric, SignedNumeric, Strideable {
    associatedtype Exponent
    static var greatestFiniteMagnitude: Self { get }
    static var infinity: Self { get }
    static var leastNonzeroMagnitude: Self { get }
    static var leastNormalMagnitude: Self { get }
    static var nan: Self { get }
    static var pi: Self { get }
    static var radix: Int { get }
    static var signalingNaN: Self { get }
    static var ulpOfOne: Self { get }
    static func maximum(_ x: Self, _ y: Self) -> Self
    static func maximumMagnitude(_ x: Self, _ y: Self) -> Self
    static func minimum(_ x: Self, _ y: Self) -> Self
    static func minimumMagnitude(_ x: Self, _ y: Self) -> Self
    init(_ value: Int)
    init(sign: FloatingPointSign, exponent: Exponent, significand: Self)
    init(signOf: Self, magnitudeOf: Self)
    var exponent: Exponent { get }
    var floatingPointClass: FloatingPointClassification { get }
    var isCanonical: Bool { get }
    var isFinite: Bool { get }
    var isInfinite: Bool { get }
    var isNaN: Bool { get }
    var isNormal: Bool { get }
    var isSignalingNaN: Bool { get }
    var isSubnormal: Bool { get }
    var isZero: Bool { get }
    var nextDown: Self { get }
    var nextUp: Self { get }
    var sign: FloatingPointSign { get }
    var significand: Self { get }
    var ulp: Self { get }
    func /(lhs: Self, rhs: Self) -> Self
    func /=(lhs: inout Self, rhs: Self)
    mutating func addProduct(_ lhs: Self, _ rhs: Self)
    func addingProduct(_ lhs: Self, _ rhs: Self) -> Self
    mutating func formRemainder(dividingBy other: Self)
    mutating func formSquareRoot()
    mutating func formTruncatingRemainder(dividingBy other: Self)
    func isEqual(to other: Self) -> Bool
    func isLess(than other: Self) -> Bool
    func isLessThanOrEqualTo(_ other: Self) -> Bool
    func isTotallyOrdered(belowOrEqualTo other: Self) -> Bool
    func remainder(dividingBy other: Self) -> Self
    mutating func round()
    mutating func round(_ rule: FloatingPointRoundingRule)
    func rounded() -> Self
    func rounded(_ rule: FloatingPointRoundingRule) -> Self
    func squareRoot() -> Self
    func truncatingRemainder(dividingBy other: Self) -> Self
}
public protocol Hashable : Equatable {
    var hashValue: Int { get }
    func hash(into hasher: inout Hasher)
}
public protocol IteratorProtocol {
    associatedtype Element
    mutating func next() -> Element?
}
public protocol KeyedDecodingContainerProtocol {
    associatedtype Key
    var allKeys: [Key] { get }
    var codingPath: [CodingKey] { get }
    func contains(_ key: Key) -> Bool
    func decode(_ type: Bool.Type, forKey key: Key) throws -> Bool
    func decodeIfPresent(_ type: Bool.Type, forKey key: Key) throws -> Bool?
    func decodeNil(forKey key: Key) throws -> Bool
    func nestedContainer<NestedKey>(keyedBy type: NestedKey.Type, forKey key: Key) throws -> KeyedDecodingContainer<NestedKey>
    func nestedUnkeyedContainer(forKey key: Key) throws -> UnkeyedDecodingContainer
    func superDecoder() throws -> Decoder
    func superDecoder(forKey key: Key) throws -> Decoder
}
public protocol KeyedEncodingContainerProtocol {
    associatedtype Key
    var codingPath: [CodingKey] { get }
    mutating func encode(_ value: Bool, forKey key: Key) throws
    mutating func encodeConditional<T>(_ object: T, forKey key: Key) throws where T : AnyObject & Encodable
    mutating func encodeIfPresent(_ value: Bool?, forKey key: Key) throws
    mutating func encodeNil(forKey key: Key) throws
    mutating func nestedContainer<NestedKey>(keyedBy keyType: NestedKey.Type, forKey key: Key) -> KeyedEncodingContainer<NestedKey>
    mutating func nestedUnkeyedContainer(forKey key: Key) -> UnkeyedEncodingContainer
    mutating func superEncoder() -> Encoder
    mutating func superEncoder(forKey key: Key) -> Encoder
}
public protocol LazyCollectionProtocol : Collection, LazySequenceProtocol, Sequence {
}
public protocol LazySequenceProtocol : Sequence {
    associatedtype Elements where Elements.Iterator.Element == Iterator.Element
    var elements: Elements { get }
    var elements: Self { get } where Elements == Self
}
public protocol LosslessStringConvertible : CustomStringConvertible {
    init?(_ description: String)
}
public protocol MirrorPath {
}
public protocol MutableCollection : Collection, Sequence {
    mutating func partition(by belongsInSecondPartition: (Element) throws -> Bool) rethrows -> Index
    mutating func reverse() where Self : BidirectionalCollection
    mutating func shuffle() where Self : RandomAccessCollection
    mutating func shuffle<T>(using generator: inout T) where Self : RandomAccessCollection, T : RandomNumberGenerator
    mutating func sort() where Element : Comparable, Self : RandomAccessCollection
    mutating func sort(by areInIncreasingOrder: (Element, Element) throws -> Bool) rethrows where Self : RandomAccessCollection
    mutating func swapAt(_ i: Index, _ j: Index)
    mutating func swapAt(_ i: Index, _ j: Index)
}
public protocol Numeric : Equatable, ExpressibleByIntegerLiteral {
    associatedtype Magnitude
    init?<T>(exactly source: T) where T : BinaryInteger
    var magnitude: Magnitude { get }
    func *(lhs: Self, rhs: Self) -> Self
    func *=(lhs: inout Self, rhs: Self)
    prefix func +(x: Self) -> Self
    func +(lhs: Self, rhs: Self) -> Self
    func +=(lhs: inout Self, rhs: Self)
    func -(lhs: Self, rhs: Self) -> Self
    func -=(lhs: inout Self, rhs: Self)
}
public protocol OptionSet : Equatable, ExpressibleByArrayLiteral, RawRepresentable, SetAlgebra {
}
public protocol RandomAccessCollection : BidirectionalCollection, Collection, Sequence {
}
public protocol RandomNumberGenerator {
    mutating func next() -> UInt64
    mutating func next<T>() -> T where T : FixedWidthInteger & UnsignedInteger
    mutating func next<T>(upperBound: T) -> T where T : FixedWidthInteger & UnsignedInteger
}
public protocol RangeExpression {
    associatedtype Bound
    func contains(_ element: Bound) -> Bool
    func relative<C>(to collection: C) -> Range<Bound> where C : Collection, Bound == C.Index
    func ~=(pattern: Self, value: Bound) -> Bool
}
public protocol RangeReplaceableCollection : Collection, Sequence {
    init()
    init<S>(_ elements: S) where S : Sequence, Element == S.Element
    init<S>(_ elements: S) where S : Sequence, Element == S.Element
    init(repeating repeatedValue: Element, count: Int)
    init(repeating repeatedValue: Element, count: Int)
    func +<Other>(lhs: Other, rhs: Self) -> Self where Other : Sequence, Element == Other.Element
    func +<Other>(lhs: Self, rhs: Other) -> Self where Other : RangeReplaceableCollection, Element == Other.Element
    func +<Other>(lhs: Self, rhs: Other) -> Self where Other : Sequence, Element == Other.Element
    func +=<Other>(lhs: inout Self, rhs: Other) where Other : Sequence, Element == Other.Element
    mutating func append(_ newElement: Element)
    mutating func append<S>(contentsOf newElements: S) where S : Sequence, Element == S.Element
    mutating func insert(_ newElement: Element, at i: Index)
    mutating func insert<C>(contentsOf newElements: C, at i: Index) where C : Collection, C.Element == Element
    mutating func popLast() -> Element? where Self : BidirectionalCollection
    @discardableResult mutating func remove(at i: Index) -> Element
    @discardableResult mutating func remove(at position: Index) -> Element
    mutating func removeAll(keepingCapacity keepCapacity: Bool = x)
    mutating func removeAll(where predicate: (Element) throws -> Bool) rethrows
    mutating func removeAll(where predicate: (Element) throws -> Bool) rethrows
    mutating func removeAll(where predicate: (Element) throws -> Bool) rethrows where Self : MutableCollection
    @discardableResult mutating func removeLast() -> Element where Self : BidirectionalCollection
    mutating func removeLast(_ k: Int) where Self : BidirectionalCollection
    mutating func removeSubrange(_ bounds: Range<Index>)
    mutating func removeSubrange(_ bounds: Range<Index>)
    mutating func replaceSubrange<C, R>(_ subrange: R, with newElements: C) where C : Collection, R : RangeExpression, C.Element == Element, Index == R.Bound
    mutating func replaceSubrange<C>(_ subrange: Range<Index>, with newElements: C) where C : Collection, C.Element == Element
    mutating func reserveCapacity(_ n: Int)
    mutating func reserveCapacity(_ n: Int)
}
public protocol RawRepresentable {
    associatedtype RawValue
    init(from decoder: Decoder) throws where Self : Decodable, Bool == RawValue
    init(from decoder: Decoder) throws where Self : Decodable, Double == RawValue
    init(from decoder: Decoder) throws where Self : Decodable, Float == RawValue
    init(from decoder: Decoder) throws where Self : Decodable, Int == RawValue
    init(from decoder: Decoder) throws where Self : Decodable, Int16 == RawValue
    init(from decoder: Decoder) throws where Self : Decodable, Int32 == RawValue
    init(from decoder: Decoder) throws where Self : Decodable, Int64 == RawValue
    init(from decoder: Decoder) throws where Self : Decodable, Int8 == RawValue
    init(from decoder: Decoder) throws where Self : Decodable, RawValue == String
    init(from decoder: Decoder) throws where Self : Decodable, RawValue == UInt
    init(from decoder: Decoder) throws where Self : Decodable, RawValue == UInt16
    init(from decoder: Decoder) throws where Self : Decodable, RawValue == UInt32
    init(from decoder: Decoder) throws where Self : Decodable, RawValue == UInt64
    init(from decoder: Decoder) throws where Self : Decodable, RawValue == UInt8
    init?(rawValue: RawValue)
    var rawValue: RawValue { get }
    func encode(to encoder: Encoder) throws where Self : Encodable, Bool == RawValue
    func encode(to encoder: Encoder) throws where Self : Encodable, Double == RawValue
    func encode(to encoder: Encoder) throws where Self : Encodable, Float == RawValue
    func encode(to encoder: Encoder) throws where Self : Encodable, Int == RawValue
    func encode(to encoder: Encoder) throws where Self : Encodable, Int16 == RawValue
    func encode(to encoder: Encoder) throws where Self : Encodable, Int32 == RawValue
    func encode(to encoder: Encoder) throws where Self : Encodable, Int64 == RawValue
    func encode(to encoder: Encoder) throws where Self : Encodable, Int8 == RawValue
    func encode(to encoder: Encoder) throws where Self : Encodable, RawValue == String
    func encode(to encoder: Encoder) throws where Self : Encodable, RawValue == UInt
    func encode(to encoder: Encoder) throws where Self : Encodable, RawValue == UInt16
    func encode(to encoder: Encoder) throws where Self : Encodable, RawValue == UInt32
    func encode(to encoder: Encoder) throws where Self : Encodable, RawValue == UInt64
    func encode(to encoder: Encoder) throws where Self : Encodable, RawValue == UInt8
}
public protocol Sequence {
    associatedtype Element
    associatedtype Iterator where Element == Iterator.Element
    associatedtype SubSequence where Element == SubSequence.Element, SubSequence == SubSequence.SubSequence
    var lazy: LazySequence<Self> { get }
    var underestimatedCount: Int { get }
    func allSatisfy(_ predicate: (Element) throws -> Bool) rethrows -> Bool
    func compactMap<ElementOfResult>(_ transform: (Element) throws -> ElementOfResult?) rethrows -> [ElementOfResult]
    func contains(_ element: Element) -> Bool where Element : Equatable
    func contains(where predicate: (Element) throws -> Bool) rethrows -> Bool
    func drop(while predicate: (Element) throws -> Bool) rethrows -> AnySequence<Element> where AnySequence<Element> == SubSequence
    func drop(while predicate: (Element) throws -> Bool) rethrows -> SubSequence
    func dropFirst() -> SubSequence
    func dropFirst(_ k: Int) -> AnySequence<Element> where AnySequence<Element> == SubSequence
    func dropFirst(_ k: Int) -> SubSequence
    func dropLast() -> SubSequence
    func dropLast(_ k: Int) -> AnySequence<Element> where AnySequence<Element> == SubSequence
    func dropLast(_ k: Int) -> SubSequence
    func elementsEqual<OtherSequence>(_ other: OtherSequence) -> Bool where Element : Equatable, OtherSequence : Sequence, Element == OtherSequence.Element
    func elementsEqual<OtherSequence>(_ other: OtherSequence, by areEquivalent: (Element, OtherSequence.Element) throws -> Bool) rethrows -> Bool where OtherSequence : Sequence
    func enumerated() -> EnumeratedSequence<Self>
    func filter(_ isIncluded: (Element) throws -> Bool) rethrows -> [Element]
    func first(where predicate: (Element) throws -> Bool) rethrows -> Element?
    func flatMap<SegmentOfResult>(_ transform: (Element) throws -> SegmentOfResult) rethrows -> [SegmentOfResult.Element] where SegmentOfResult : Sequence
    func forEach(_ body: (Element) throws -> Void) rethrows
    func joined() -> FlattenSequence<Self> where Element : Sequence
    func joined(separator: String = x) -> String where Element : StringProtocol
    func joined<Separator>(separator: Separator) -> JoinedSequence<Self> where Element : Sequence, Separator : Sequence, Element.Element == Separator.Element
    func lexicographicallyPrecedes<OtherSequence>(_ other: OtherSequence) -> Bool where Element : Comparable, OtherSequence : Sequence, Element == OtherSequence.Element
    func lexicographicallyPrecedes<OtherSequence>(_ other: OtherSequence, by areInIncreasingOrder: (Element, Element) throws -> Bool) rethrows -> Bool where OtherSequence : Sequence, Element == OtherSequence.Element
    func makeIterator() -> Iterator
    func map<T>(_ transform: (Element) throws -> T) rethrows -> [T]
    func max() -> Element? where Element : Comparable
    func max(by areInIncreasingOrder: (Element, Element) throws -> Bool) rethrows -> Element?
    func min() -> Element? where Element : Comparable
    func min(by areInIncreasingOrder: (Element, Element) throws -> Bool) rethrows -> Element?
    func prefix(_ maxLength: Int) -> AnySequence<Element> where AnySequence<Element> == SubSequence
    func prefix(_ maxLength: Int) -> SubSequence
    func prefix(while predicate: (Element) throws -> Bool) rethrows -> AnySequence<Element> where AnySequence<Element> == SubSequence
    func reduce<Result>(_ initialResult: Result, _ nextPartialResult: (_ partialResult: Result, Element) throws -> Result) rethrows -> Result
    func reduce<Result>(into initialResult: Result, _ updateAccumulatingResult: (_ partialResult: inout Result, Element) throws -> Void) rethrows -> Result
    func reversed() -> [Element]
    func shuffled() -> [Element]
    func shuffled<T>(using generator: inout T) -> [Element] where T : RandomNumberGenerator
    func sorted() -> [Element] where Element : Comparable
    func sorted(by areInIncreasingOrder: (Element, Element) throws -> Bool) rethrows -> [Element]
    func split(maxSplits: Int = x, omittingEmptySubsequences: Bool = x, whereSeparator isSeparator: (Element) throws -> Bool) rethrows -> [AnySequence<Element>] where AnySequence<Element> == SubSequence
    func split(maxSplits: Int, omittingEmptySubsequences: Bool, whereSeparator isSeparator: (Element) throws -> Bool) rethrows -> [SubSequence]
    func split(separator: Element, maxSplits: Int = x, omittingEmptySubsequences: Bool = x) -> [SubSequence] where Element : Equatable
    func starts<PossiblePrefix>(with possiblePrefix: PossiblePrefix) -> Bool where Element : Equatable, PossiblePrefix : Sequence, Element == PossiblePrefix.Element
    func starts<PossiblePrefix>(with possiblePrefix: PossiblePrefix, by areEquivalent: (Element, PossiblePrefix.Element) throws -> Bool) rethrows -> Bool where PossiblePrefix : Sequence
    func suffix(_ maxLength: Int) -> AnySequence<Element> where AnySequence<Element> == SubSequence
    func suffix(_ maxLength: Int) -> SubSequence
}
public protocol SetAlgebra : Equatable, ExpressibleByArrayLiteral {
    associatedtype Element
    init()
    init<S>(_ sequence: S) where S : Sequence, Element == S.Element
    var isEmpty: Bool { get }
    func contains(_ member: Element) -> Bool
    mutating func formIntersection(_ other: Self)
    mutating func formSymmetricDifference(_ other: Self)
    mutating func formUnion(_ other: Self)
    @discardableResult mutating func insert(_ newMember: Element) -> (inserted : Bool, memberAfterInsert : Element)
    func intersection(_ other: Self) -> Self
    func isDisjoint(with other: Self) -> Bool
    func isStrictSubset(of other: Self) -> Bool
    func isStrictSuperset(of other: Self) -> Bool
    func isSubset(of other: Self) -> Bool
    func isSuperset(of other: Self) -> Bool
    func isSuperset(of other: Self) -> Bool
    @discardableResult mutating func remove(_ member: Element) -> Element?
    mutating func subtract(_ other: Self)
    func subtracting(_ other: Self) -> Self
    func subtracting(_ other: Self) -> Self
    func symmetricDifference(_ other: Self) -> Self
    func union(_ other: Self) -> Self
    @discardableResult mutating func update(with newMember: Element) -> Element?
}
public protocol SignedInteger : BinaryInteger, Comparable, CustomStringConvertible, Equatable, ExpressibleByIntegerLiteral, Hashable, Numeric, SignedNumeric, Strideable {
    static var max: Self { get } where Self : FixedWidthInteger
    static var min: Self { get } where Self : FixedWidthInteger
    func &+(lhs: Self, rhs: Self) -> Self where Self : FixedWidthInteger
    func &-(lhs: Self, rhs: Self) -> Self where Self : FixedWidthInteger
}
public protocol SignedNumeric : Equatable, ExpressibleByIntegerLiteral, Numeric {
    prefix func -(operand: Self) -> Self
    prefix func -(operand: Self) -> Self
    mutating func negate()
}
public protocol SingleValueDecodingContainer {
    var codingPath: [CodingKey] { get }
    func decode(_ type: Bool.Type) throws -> Bool
    func decodeNil() -> Bool
}
public protocol SingleValueEncodingContainer {
    var codingPath: [CodingKey] { get }
    mutating func encode(_ value: Bool) throws
    mutating func encodeNil() throws
}
public protocol Strideable : Comparable, Equatable {
    associatedtype Stride
    func +(lhs: Self, rhs: Stride) -> Self where Self : _Pointer
    func +=(lhs: inout Self, rhs: Stride) where Self : _Pointer
    func -(lhs: Self, rhs: Self) -> Stride where Self : _Pointer
    func -=(lhs: inout Self, rhs: Stride) where Self : _Pointer
    func advanced(by n: Stride) -> Self
    func distance(to other: Self) -> Stride
}
public protocol StringProtocol : BidirectionalCollection, Collection, Comparable, CustomStringConvertible, Equatable, ExpressibleByExtendedGraphemeClusterLiteral, ExpressibleByStringLiteral, ExpressibleByUnicodeScalarLiteral, Hashable, LosslessStringConvertible, Sequence, TextOutputStream, TextOutputStreamable {
    associatedtype UTF16View where UInt16 == UTF16View.Element
    associatedtype UTF8View where UInt8 == UTF8View.Element
    associatedtype UnicodeScalarView where Unicode.Scalar == UnicodeScalarView.Element
    init(cString nullTerminatedUTF8: UnsafePointer<CChar>)
    init<C, Encoding>(decoding codeUnits: C, as sourceEncoding: Encoding.Type) where C : Collection, Encoding : Unicode.Encoding, C.Iterator.Element == Encoding.CodeUnit
    init<Encoding>(decodingCString nullTerminatedCodeUnits: UnsafePointer<Encoding.CodeUnit>, as sourceEncoding: Encoding.Type) where Encoding : Unicode.Encoding
    var unicodeScalars: UnicodeScalarView { get }
    var utf16: UTF16View { get }
    var utf8: UTF8View { get }
    func hasPrefix<Prefix>(_ prefix: Prefix) -> Bool where Prefix : StringProtocol
    func hasSuffix<Suffix>(_ suffix: Suffix) -> Bool where Suffix : StringProtocol
    func lowercased() -> String
    func uppercased() -> String
    func withCString<Result>(_ body: (UnsafePointer<CChar>) throws -> Result) rethrows -> Result
    func withCString<Result, Encoding>(encodedAs targetEncoding: Encoding.Type, _ body: (UnsafePointer<Encoding.CodeUnit>) throws -> Result) rethrows -> Result where Encoding : Unicode.Encoding
}
public protocol TextOutputStream {
    mutating func write(_ string: String)
}
public protocol TextOutputStreamable {
    func write<Target>(to target: inout Target) where Target : TextOutputStream
}
public protocol UnicodeCodec : Unicode.Encoding {
    static func encode(_ input: Unicode.Scalar, into processCodeUnit: (CodeUnit) -> Void)
    init()
    mutating func decode<I>(_ input: inout I) -> UnicodeDecodingResult where I : IteratorProtocol, CodeUnit == I.Element
}
public protocol UnkeyedDecodingContainer {
    var codingPath: [CodingKey] { get }
    var count: Int? { get }
    var currentIndex: Int { get }
    var isAtEnd: Bool { get }
    mutating func decode(_ type: Bool.Type) throws -> Bool
    mutating func decodeIfPresent(_ type: Bool.Type) throws -> Bool?
    mutating func decodeNil() throws -> Bool
    mutating func nestedContainer<NestedKey>(keyedBy type: NestedKey.Type) throws -> KeyedDecodingContainer<NestedKey>
    mutating func nestedUnkeyedContainer() throws -> UnkeyedDecodingContainer
    mutating func superDecoder() throws -> Decoder
}
public protocol UnkeyedEncodingContainer {
    var codingPath: [CodingKey] { get }
    var count: Int { get }
    mutating func encode(_ value: Bool) throws
    mutating func encode<T>(contentsOf sequence: T) throws where T : Sequence, Bool == T.Iterator.Element
    mutating func encodeConditional<T>(_ object: T) throws where T : AnyObject & Encodable
    mutating func encodeNil() throws
    mutating func nestedContainer<NestedKey>(keyedBy keyType: NestedKey.Type) -> KeyedEncodingContainer<NestedKey>
    mutating func nestedUnkeyedContainer() -> UnkeyedEncodingContainer
    mutating func superEncoder() -> Encoder
}
public protocol UnsignedInteger : BinaryInteger, Comparable, CustomStringConvertible, Equatable, ExpressibleByIntegerLiteral, Hashable, Numeric, Strideable {
    static var max: Self { get } where Self : FixedWidthInteger
    static var min: Self { get } where Self : FixedWidthInteger
}
extension AnyBidirectionalCollection {
    public init(_ other: AnyBidirectionalCollection<Element>) {}
    public init<C>(_ base: C) where C : BidirectionalCollection, C.Element == Element {}
    public init?(_ other: AnyCollection<Element>) {}
}
extension AnyCollection {
    public init(_ other: AnyBidirectionalCollection<Element>) {}
    public init<C>(_ base: C) where C : BidirectionalCollection, C.Element == Element {}
}
extension AnyIterator {
}
extension AnyRandomAccessCollection {
    public init(_ other: AnyRandomAccessCollection<Element>) {}
    public init<C>(_ base: C) where C : RandomAccessCollection, C.Element == Element {}
    public init?(_ other: AnyBidirectionalCollection<Element>) {}
}
extension AnySequence {
    public init<S>(_ base: S) where S : Sequence, Element == S.Element {}
}
extension Array {
    public var capacity: Int { get }
    public func withUnsafeBufferPointer<R>(_ body: (UnsafeBufferPointer<Element>) throws -> R) rethrows -> R {}
    public func withUnsafeBytes<R>(_ body: (UnsafeRawBufferPointer) throws -> R) rethrows -> R {}
    public mutating func withUnsafeMutableBufferPointer<R>(_ body: (inout UnsafeMutableBufferPointer<Element>) throws -> R) rethrows -> R {}
    public mutating func withUnsafeMutableBytes<R>(_ body: (UnsafeMutableRawBufferPointer) throws -> R) rethrows -> R {}
}
extension ArrayProtocol {
    public func filter(_ isIncluded: (Element) throws -> Bool) rethrows -> [Element] {}
}
extension ArraySlice {
    public var capacity: Int { get }
    public func withUnsafeBufferPointer<R>(_ body: (UnsafeBufferPointer<Element>) throws -> R) rethrows -> R {}
    public func withUnsafeBytes<R>(_ body: (UnsafeRawBufferPointer) throws -> R) rethrows -> R {}
    public mutating func withUnsafeMutableBufferPointer<R>(_ body: (inout UnsafeMutableBufferPointer<Element>) throws -> R) rethrows -> R {}
    public mutating func withUnsafeMutableBytes<R>(_ body: (UnsafeMutableRawBufferPointer) throws -> R) rethrows -> R {}
}
extension AutoreleasingUnsafeMutablePointer {
}
extension Character.UnicodeScalarView {
    public subscript(i: Index) -> UnicodeScalar { get } {}
}
extension Character.UnicodeScalarView.Index {
}
extension Character.UnicodeScalarView.Iterator {
}
extension ClosedRange {
    public init(_ other: Range<Bound>) where Bound : Strideable, Bound.Stride : SignedInteger {}
    public func clamped(to limits: ClosedRange) -> ClosedRange {}
    public func overlaps(_ other: ClosedRange<Bound>) -> Bool {}
}
extension ClosedRange.Index {
}
extension CollectionOfOne {
}
extension ContiguousArray {
    public var capacity: Int { get }
    public func withUnsafeBufferPointer<R>(_ body: (UnsafeBufferPointer<Element>) throws -> R) rethrows -> R {}
    public func withUnsafeBytes<R>(_ body: (UnsafeRawBufferPointer) throws -> R) rethrows -> R {}
    public mutating func withUnsafeMutableBufferPointer<R>(_ body: (inout UnsafeMutableBufferPointer<Element>) throws -> R) rethrows -> R {}
    public mutating func withUnsafeMutableBytes<R>(_ body: (UnsafeMutableRawBufferPointer) throws -> R) rethrows -> R {}
}
extension DefaultIndices {
    public subscript(i: Index) -> Elements.Index { get } {}
}
extension Dictionary {
    public var capacity: Int { get }
    @available(swift, introduced: 4.0) public var keys: Keys { get }
    @available(swift, introduced: 4.0) public var values: Values { get set }
    public subscript(key: Key) -> Value? { get set } {}
    public func index(forKey key: Key) -> Index? {}
    public func mapValues<T>(_ transform: (Value) throws -> T) rethrows -> [Key: T] {}
    public mutating func merge(_ other: [Key: Value], uniquingKeysWith combine: (Value, Value) throws -> Value) rethrows {}
    public mutating func merge<S>(_ other: S, uniquingKeysWith combine: (Value, Value) throws -> Value) rethrows where S : Sequence, (Key, Value) == S.Element {}
    public func merging(_ other: [Key: Value], uniquingKeysWith combine: (Value, Value) throws -> Value) rethrows -> [Key: Value] {}
    public func merging<S>(_ other: S, uniquingKeysWith combine: (Value, Value) throws -> Value) rethrows -> [Key: Value] where S : Sequence, (Key, Value) == S.Element {}
    @discardableResult public mutating func remove(at index: Index) -> Element {}
    public mutating func removeAll(keepingCapacity keepCapacity: Bool = x) {}
    @discardableResult public mutating func removeValue(forKey key: Key) -> Value? {}
    public mutating func reserveCapacity(_ minimumCapacity: Int) {}
    @discardableResult public mutating func updateValue(_ value: Value, forKey key: Key) -> Value? {}
}
extension Dictionary.Index {
    public var hashValue: Int { get }
    public func <(lhs: [Key: Value].Index, rhs: [Key: Value].Index) -> Bool {}
    public func ==(lhs: [Key: Value].Index, rhs: [Key: Value].Index) -> Bool {}
    public func hash(into hasher: inout Hasher) {}
}
extension DictionaryIterator {
}
extension DictionaryLiteral {
}
extension EmptyCollection {
}
extension EmptyCollection.Iterator {
}
extension EnumeratedIterator {
}
extension EnumeratedSequence {
}
extension FlattenCollection {
}
extension FlattenCollection.Index {
}
extension FlattenSequence {
}
extension FlattenSequence.Iterator {
}
extension IndexingIterator {
}
extension IteratorOverOne {
}
extension IteratorSequence {
}
extension JoinedSequence {
}
extension JoinedSequence.Iterator {
}
extension LazyCollection {
}
extension LazyDropWhileCollection {
}
extension LazyDropWhileCollection.Index {
}
extension LazyDropWhileSequence {
}
extension LazyDropWhileSequence.Iterator {
}
extension LazyFilterCollection {
}
extension LazyFilterSequence {
}
extension LazyFilterSequence.Iterator {
}
extension LazyMapCollection {
}
extension LazyMapSequence {
}
extension LazyMapSequence.Iterator {
}
extension LazyPrefixWhileCollection {
}
extension LazyPrefixWhileCollection.Index {
}
extension LazyPrefixWhileSequence {
}
extension LazyPrefixWhileSequence.Iterator {
}
extension LazySequence {
}
extension MemoryLayout {
    public static func alignment(ofValue value: T) -> Int {}
    public static func offset(of key: PartialKeyPath<T>) -> Int? {}
    public static func size(ofValue value: T) -> Int {}
    public static func stride(ofValue value: T) -> Int {}
}
extension Optional {
    public func ~=(lhs: _OptionalNilComparisonType, rhs: Wrapped?) -> Bool {}
}
extension PartialRangeFrom {
}
extension PartialRangeThrough {
}
extension PartialRangeUpTo {
}
extension Range {
    public init(_ other: ClosedRange<Bound>) where Bound : Strideable, Bound.Stride : SignedInteger {}
    public func clamped(to limits: Range) -> Range {}
    public func overlaps(_ other: Range<Bound>) -> Bool {}
}
extension Repeated {
}
extension ReversedCollection {
}
extension ReversedCollection.Index {
}
extension ReversedCollection.Iterator {
}
extension Set {
    public init(minimumCapacity: Int) {}
    public var capacity: Int { get }
    @discardableResult public mutating func remove(at position: Index) -> Element {}
    public mutating func removeAll(keepingCapacity keepCapacity: Bool = x) {}
    public mutating func reserveCapacity(_ minimumCapacity: Int) {}
}
extension Set.Index {
    public var hashValue: Int { get }
    public func <(lhs: Set<Element>.Index, rhs: Set<Element>.Index) -> Bool {}
    public func ==(lhs: Set<Element>.Index, rhs: Set<Element>.Index) -> Bool {}
    public func hash(into hasher: inout Hasher) {}
}
extension SetIterator {
}
extension Slice {
    public subscript(index: Index) -> Base.Element { get set } where Base : MutableCollection {}
}
extension StrideThrough {
}
extension StrideThroughIterator {
}
extension StrideTo {
}
extension StrideToIterator {
}
extension String.Index {
    public init(encodedOffset offset: Int) {}
    public var encodedOffset: Int { get }
}
extension String.UTF8View.Iterator {
}
extension String.UnicodeScalarIndex {
    public init?(_ sourcePosition: String.UTF16Index, within unicodeScalars: String.UnicodeScalarView) {}
    public func samePosition(in characters: String) -> String.Index? {}
}
extension String._CharacterView {
    public subscript(i: Index) -> Character { get } {}
}
extension Substring._CharacterView {
    public subscript(index: Index) -> Element { get } {}
}
extension UTF16.CodeUnit {
}
extension UTF16.ReverseParser {
}
extension UTF32.Parser {
    public mutating func parseScalar<I>(from input: inout I) -> Unicode.ParseResult<Encoding.EncodedScalar> where I : IteratorProtocol, Encoding.CodeUnit == I.Element {}
}
extension UTF8.CodeUnit {
}
extension UTF8.ReverseParser {
}
extension Unicode.ASCII {
    public static var encodedReplacementCharacter: EncodedScalar { get }
    public static func decode(_ source: EncodedScalar) -> Unicode.Scalar {}
    public static func encode(_ source: Unicode.Scalar) -> EncodedScalar? {}
    public static func transcode<FromEncoding>(_ content: FromEncoding.EncodedScalar, from _: FromEncoding.Type) -> EncodedScalar? where FromEncoding : Unicode.Encoding {}
}
extension Unicode.ASCII.Parser {
    public mutating func parseScalar<I>(from input: inout I) -> Unicode.ParseResult<Encoding.EncodedScalar> where I : IteratorProtocol, Encoding.CodeUnit == I.Element {}
}
extension Unicode.Scalar {
}
extension Unicode.UTF16.ForwardParser {
}
extension Unicode._ParsingIterator {
}
extension UnsafeBufferPointer {
    public init(_ other: UnsafeMutableBufferPointer<Element>) {}
    public init(rebasing slice: Slice<UnsafeBufferPointer<Element>>) {}
    public init(start: UnsafePointer<Element>?, count: Int) {}
    public var baseAddress: UnsafePointer<Element>? { get }
    public subscript(i: Int) -> Element { get } {}
    public func deallocate() {}
    public func withMemoryRebound<T, Result>(to type: T.Type, _ body: (UnsafeBufferPointer<T>) throws -> Result) rethrows -> Result {}
}
extension UnsafeBufferPointer.Iterator {
}
extension UnsafeMutableBufferPointer {
    public static func allocate(capacity count: Int) -> UnsafeMutableBufferPointer<Element> {}
    public init(mutating other: UnsafeBufferPointer<Element>) {}
    public init(rebasing slice: Slice<UnsafeMutableBufferPointer<Element>>) {}
    public init(start: UnsafeMutablePointer<Element>?, count: Int) {}
    public var baseAddress: UnsafeMutablePointer<Element>? { get }
    public subscript(i: Int) -> Element { get set } {}
    public func assign(repeating repeatedValue: Element) {}
    public func deallocate() {}
    public func initialize<S>(from source: S) -> (S.Iterator, Index) where S : Sequence, Element == S.Element {}
    public func initialize(repeating repeatedValue: Element) {}
    public func withMemoryRebound<T, Result>(to type: T.Type, _ body: (UnsafeMutableBufferPointer<T>) throws -> Result) rethrows -> Result {}
}
extension UnsafeMutablePointer {
    public func predecessor() -> UnsafeMutablePointer {}
    public func successor() -> UnsafeMutablePointer {}
}
extension UnsafePointer {
    public func predecessor() -> UnsafePointer {}
    public func successor() -> UnsafePointer {}
}
extension Zip2Sequence {
}
extension Zip2Sequence.Iterator {
}