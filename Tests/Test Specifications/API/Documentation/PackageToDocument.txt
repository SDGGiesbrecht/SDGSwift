A Boolean value indicating whether the collection is empty.

When you need to check whether your collection is empty, use the
`isEmpty` property instead of checking that the `count` property is
equal to zero. For collections that don't conform to
`RandomAccessCollection`, accessing the `count` property iterates
through the elements of the collection.

    let horseName = "Silver"
    if horseName.isEmpty {
        print("My horse has no name.")
    } else {
        print("Hi ho, \(horseName)!")
    }
    // Prints "Hi ho, Silver!")

- Complexity: O(1)

A sequence containing the same elements as this sequence,
but on which some operations, such as `map` and `filter`, are
implemented lazily.

A type that represents a position in the collection.

Valid indices consist of the position of every element and a
"past the end" position that's not valid for use as a subscript
argument.

A type that represents the indices that are valid for subscripting the
collection, in ascending order.

A value less than or equal to the number of elements in the collection.

- Complexity: O(1) if the collection conforms to
  `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
  of the collection.

A value less than or equal to the number of elements in the sequence,
calculated nondestructively.

The default implementation returns 0. If you provide your own
implementation, make sure to compute the value nondestructively.

- Complexity: O(1), except if the sequence also conforms to `Collection`.
  In this case, see the documentation of `Collection.underestimatedCount`.

Accesses a contiguous subrange of the collection's elements.

The accessed slice uses the same indices for the same elements as the
original collection. Always use the slice's `startIndex` property
instead of assuming that its indices start at a particular value.

This example demonstrates getting a slice of an array of strings, finding
the index of one of the strings in the slice, and then using that index
in the original array.

    let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    let streetsSlice = streets[2 ..< streets.endIndex]
    print(streetsSlice)
    // Prints "["Channing", "Douglas", "Evarts"]"

    let index = streetsSlice.firstIndex(of: "Evarts")    // 4
    print(streets[index!])
    // Prints "Evarts"

- Parameter bounds: A range of the collection's indices. The bounds of
  the range must be valid indices of the collection.

- Complexity: O(1)

Accesses the contiguous subrange of the collection's elements specified
by a range expression.

The range expression is converted to a concrete subrange relative to this
collection. For example, using a `PartialRangeFrom` range expression
with an array accesses the subrange from the start of the range
expression until the end of the array.

    let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    let streetsSlice = streets[2...]
    print(streetsSlice)
    // ["Channing", "Douglas", "Evarts"]

The accessed slice uses the same indices for the same elements as the
original collection uses. This example searches `streetsSlice` for one
of the strings in the slice, and then uses that index in the original
array.

    let index = streetsSlice.firstIndex(of: "Evarts")    // 4
    print(streets[index!])
    // "Evarts"

Always use the slice's `startIndex` property instead of assuming that its
indices start at a particular value. Attempting to access an element by
using an index outside the bounds of the slice's indices may result in a
runtime error, even if that index is valid for the original collection.

    print(streetsSlice.startIndex)
    // 2
    print(streetsSlice[2])
    // "Channing"

    print(streetsSlice[0])
    // error: Index out of bounds

- Parameter bounds: A range of the collection's indices. The bounds of
  the range must be valid indices of the collection.

- Complexity: O(1)

Accesses the element at the specified position.

The following example accesses an element of an array through its
subscript to print its value:

    var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    print(streets[1])
    // Prints "Bryant"

You can subscript a collection with any valid index other than the
collection's end index. The end index refers to the position one past
the last element of a collection, so it doesn't correspond with an
element.

- Parameter position: The position of the element to access. `position`
  must be a valid index of the collection that is not equal to the
  `endIndex` property.

- Complexity: O(1)

Calls the given closure on each element in the sequence in the same order
as a `for`-`in` loop.

The two loops in the following example produce the same output:

    let numberWords = ["one", "two", "three"]
    for word in numberWords {
        print(word)
    }
    // Prints "one"
    // Prints "two"
    // Prints "three"

    numberWords.forEach { word in
        print(word)
    }
    // Same as above

Using the `forEach` method is distinct from a `for`-`in` loop in two
important ways:

1. You cannot use a `break` or `continue` statement to exit the current
   call of the `body` closure or skip subsequent calls.
2. Using the `return` statement in the `body` closure will exit only from
   the current call to `body`, not from any outer scope, and won't skip
   subsequent calls.

- Parameter body: A closure that takes an element of the sequence as a
  parameter.

Creates a new instance by decoding from the given decoder.

This initializer throws an error if reading from the decoder fails, or
if the data read is corrupted or otherwise invalid.

- Parameter decoder: The decoder to read data from.

Creates a new instance from an interpolated string literal.

Don't call this initializer directly. It's used by the compiler when
you create a string using string interpolation. Instead, use string
interpolation to create a new string by including values, literals,
variables, or expressions enclosed in parentheses, prefixed by a
backslash (`\(`...`)`).

    let price = 2
    let number = 3
    let message = """
                  If one cookie costs \(price) dollars, \
                  \(number) cookies cost \(price * number) dollars.
                  """
    // message == "If one cookie costs 2 dollars, 3 cookies cost 6 dollars."

Creates a new instance with the specified raw value.

If there is no value of the type that corresponds with the specified raw
value, this initializer returns `nil`. For example:

    enum PaperSize: String {
        case A4, A5, Letter, Legal
    }

    print(PaperSize(rawValue: "Legal"))
    // Prints "Optional("PaperSize.Legal")"

    print(PaperSize(rawValue: "Tabloid"))
    // Prints "nil"

- Parameter rawValue: The raw value to use for the new instance.

Creates an instance from a string interpolation.

Most `StringInterpolation` types will store information about the
literals and interpolations appended to them in one or more properties.
`init(stringInterpolation:)` should use these properties to initialize
the instance.

- Parameter stringInterpolation: An instance of `StringInterpolation`
            which has had each segment of the string literal appended
            to it.

Creates an instance initialized to the given string value.

- Parameter value: The value of the new instance.

Creates an instance initialized to the given value.

- Parameter value: The value of the new instance.

Creates an instance initialized to the given value.

- Parameter value: The value of the new instance.

Encodes this value into the given encoder.

If the value fails to encode anything, `encoder` will encode an empty
keyed container in its place.

This function throws an error if any values are invalid for the given
encoder's format.

- Parameter encoder: The encoder to write data to.

Executes a closure on the sequence’s contiguous storage.

This method calls `body(buffer)`, where `buffer` is a pointer to the
collection’s contiguous storage. If the contiguous storage doesn't exist,
the collection creates it. If the collection doesn’t support an internal
representation in a form of contiguous storage, the method doesn’t call
`body` --- it immediately returns `nil`.

The optimizer can often eliminate bounds- and uniqueness-checking
within an algorithm. When that fails, however, invoking the same
algorithm on the `buffer` argument may let you trade safety for speed.

Successive calls to this method may provide a different pointer on each
call. Don't store `buffer` outside of this method.

A `Collection` that provides its own implementation of this method
must provide contiguous storage to its elements in the same order
as they appear in the collection. This guarantees that it's possible to
generate contiguous mutable storage to any of its subsequences by slicing
`buffer` with a range formed from the distances to the subsequence's
`startIndex` and `endIndex`, respectively.

- Parameters:
  - body: A closure that receives an `UnsafeBufferPointer` to the
    sequence's contiguous storage.
- Returns: The value returned from `body`, unless the sequence doesn't
  support contiguous storage, in which case the method ignores `body` and
  returns `nil`.

Offsets the given index by the specified distance, or so that it equals
the given limiting index.

The value passed as `distance` must not offset `i` beyond the bounds of
the collection, unless the index passed as `limit` prevents offsetting
beyond those bounds.

- Parameters:
  - i: A valid index of the collection.
  - distance: The distance to offset `i`. `distance` must not be negative
    unless the collection conforms to the `BidirectionalCollection`
    protocol.
  - limit: A valid index of the collection to use as a limit. If
    `distance > 0`, a limit that is less than `i` has no effect.
    Likewise, if `distance < 0`, a limit that is greater than `i` has no
    effect.
- Returns: `true` if `i` has been offset by exactly `distance` steps
  without going beyond `limit`; otherwise, `false`. When the return
  value is `false`, the value of `i` is equal to `limit`.

- Complexity: O(1) if the collection conforms to
  `RandomAccessCollection`; otherwise, O(*k*), where *k* is the absolute
  value of `distance`.

Offsets the given index by the specified distance.

The value passed as `distance` must not offset `i` beyond the bounds of
the collection.

- Parameters:
  - i: A valid index of the collection.
  - distance: The distance to offset `i`. `distance` must not be negative
    unless the collection conforms to the `BidirectionalCollection`
    protocol.

- Complexity: O(1) if the collection conforms to
  `RandomAccessCollection`; otherwise, O(*k*), where *k* is the absolute
  value of `distance`.

Replaces the given index with its successor.

- Parameter i: A valid index of the collection. `i` must be less than
  `endIndex`.

Returns a Boolean value indicating whether every element of a sequence
satisfies a given predicate.

The following code uses this method to test whether all the names in an
array have at least five characters:

    let names = ["Sofia", "Camilla", "Martina", "Mateo", "Nicolás"]
    let allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })
    // allHaveAtLeastFive == true

- Parameter predicate: A closure that takes an element of the sequence
  as its argument and returns a Boolean value that indicates whether
  the passed element satisfies a condition.
- Returns: `true` if the sequence contains only elements that satisfy
  `predicate`; otherwise, `false`.

- Complexity: O(*n*), where *n* is the length of the sequence.

Returns a Boolean value indicating whether the initial elements of the
sequence are equivalent to the elements in another sequence, using
the given predicate as the equivalence test.

The predicate must be a *equivalence relation* over the elements. That
is, for any elements `a`, `b`, and `c`, the following conditions must
hold:

- `areEquivalent(a, a)` is always `true`. (Reflexivity)
- `areEquivalent(a, b)` implies `areEquivalent(b, a)`. (Symmetry)
- If `areEquivalent(a, b)` and `areEquivalent(b, c)` are both `true`, then
  `areEquivalent(a, c)` is also `true`. (Transitivity)

- Parameters:
  - possiblePrefix: A sequence to compare to this sequence.
  - areEquivalent: A predicate that returns `true` if its two arguments
    are equivalent; otherwise, `false`.
- Returns: `true` if the initial elements of the sequence are equivalent
  to the elements of `possiblePrefix`; otherwise, `false`. If
  `possiblePrefix` has no elements, the return value is `true`.

- Complexity: O(*m*), where *m* is the lesser of the length of the
  sequence and the length of `possiblePrefix`.

Returns a Boolean value indicating whether the initial elements of the
sequence are the same as the elements in another sequence.

This example tests whether one countable range begins with the elements
of another countable range.

    let a = 1...3
    let b = 1...10

    print(b.starts(with: a))
    // Prints "true"

Passing a sequence with no elements or an empty collection as
`possiblePrefix` always results in `true`.

    print(b.starts(with: []))
    // Prints "true"

- Parameter possiblePrefix: A sequence to compare to this sequence.
- Returns: `true` if the initial elements of the sequence are the same as
  the elements of `possiblePrefix`; otherwise, `false`. If
  `possiblePrefix` has no elements, the return value is `true`.

- Complexity: O(*m*), where *m* is the lesser of the length of the
  sequence and the length of `possiblePrefix`.

Returns a Boolean value indicating whether the sequence contains an
element that satisfies the given predicate.

You can use the predicate to check for an element of a type that
doesn't conform to the `Equatable` protocol, such as the
`HTTPResponse` enumeration in this example.

    enum HTTPResponse {
        case ok
        case error(Int)
    }

    let lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]
    let hadError = lastThreeResponses.contains { element in
        if case .error = element {
            return true
        } else {
            return false
        }
    }
    // 'hadError' == true

Alternatively, a predicate can be satisfied by a range of `Equatable`
elements or a general condition. This example shows how you can check an
array for an expense greater than $100.

    let expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]
    let hasBigPurchase = expenses.contains { $0 > 100 }
    // 'hasBigPurchase' == true

- Parameter predicate: A closure that takes an element of the sequence
  as its argument and returns a Boolean value that indicates whether
  the passed element represents a match.
- Returns: `true` if the sequence contains an element that satisfies
  `predicate`; otherwise, `false`.

- Complexity: O(*n*), where *n* is the length of the sequence.

Returns a Boolean value indicating whether the sequence contains the
given element.

This example checks to see whether a favorite actor is in an array
storing a movie's cast.

    let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    print(cast.contains("Marlon"))
    // Prints "true"
    print(cast.contains("James"))
    // Prints "false"

- Parameter element: The element to find in the sequence.
- Returns: `true` if the element was found in the sequence; otherwise,
  `false`.

- Complexity: O(*n*), where *n* is the length of the sequence.

Returns a Boolean value indicating whether the sequence precedes another
sequence in a lexicographical (dictionary) ordering, using the
less-than operator (`<`) to compare elements.

This example uses the `lexicographicallyPrecedes` method to test which
array of integers comes first in a lexicographical ordering.

    let a = [1, 2, 2, 2]
    let b = [1, 2, 3, 4]

    print(a.lexicographicallyPrecedes(b))
    // Prints "true"
    print(b.lexicographicallyPrecedes(b))
    // Prints "false"

- Parameter other: A sequence to compare to this sequence.
- Returns: `true` if this sequence precedes `other` in a dictionary
  ordering; otherwise, `false`.

- Note: This method implements the mathematical notion of lexicographical
  ordering, which has no connection to Unicode.  If you are sorting
  strings to present to the end user, use `String` APIs that
  perform localized comparison.

- Complexity: O(*m*), where *m* is the lesser of the length of the
  sequence and the length of `other`.

Returns a Boolean value indicating whether the sequence precedes another
sequence in a lexicographical (dictionary) ordering, using the given
predicate to compare elements.

The predicate must be a *strict weak ordering* over the elements. That
is, for any elements `a`, `b`, and `c`, the following conditions must
hold:

- `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)
- If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are
  both `true`, then `areInIncreasingOrder(a, c)` is also
  `true`. (Transitive comparability)
- Two elements are *incomparable* if neither is ordered before the other
  according to the predicate. If `a` and `b` are incomparable, and `b`
  and `c` are incomparable, then `a` and `c` are also incomparable.
  (Transitive incomparability)

- Parameters:
  - other: A sequence to compare to this sequence.
  - areInIncreasingOrder:  A predicate that returns `true` if its first
    argument should be ordered before its second argument; otherwise,
    `false`.
- Returns: `true` if this sequence precedes `other` in a dictionary
  ordering as ordered by `areInIncreasingOrder`; otherwise, `false`.

- Note: This method implements the mathematical notion of lexicographical
  ordering, which has no connection to Unicode.  If you are sorting
  strings to present to the end user, use `String` APIs that perform
  localized comparison instead.

- Complexity: O(*m*), where *m* is the lesser of the length of the
  sequence and the length of `other`.

Returns a Boolean value indicating whether the value of the first
argument is less than that of the second argument.

This function is the only requirement of the `Comparable` protocol. The
remainder of the relational operator functions are implemented by the
standard library for any type that conforms to `Comparable`.

- Parameters:
  - lhs: A value to compare.
  - rhs: Another value to compare.

Returns a Boolean value indicating whether the value of the first argument
is greater than or equal to that of the second argument.

This is the default implementation of the greater-than-or-equal-to operator
(`>=`) for any type that conforms to `Comparable`.

- Parameters:
  - lhs: A value to compare.
  - rhs: Another value to compare.
- Returns: `true` if `lhs` is greater than or equal to `rhs`; otherwise,
  `false`.

Returns a Boolean value indicating whether the value of the first argument
is greater than that of the second argument.

This is the default implementation of the greater-than operator (`>`) for
any type that conforms to `Comparable`.

- Parameters:
  - lhs: A value to compare.
  - rhs: Another value to compare.

Returns a Boolean value indicating whether the value of the first argument
is less than or equal to that of the second argument.

This is the default implementation of the less-than-or-equal-to
operator (`<=`) for any type that conforms to `Comparable`.

- Parameters:
  - lhs: A value to compare.
  - rhs: Another value to compare.

Returns a Boolean value indicating whether this sequence and another
sequence contain equivalent elements in the same order, using the given
predicate as the equivalence test.

At least one of the sequences must be finite.

The predicate must be a *equivalence relation* over the elements. That
is, for any elements `a`, `b`, and `c`, the following conditions must
hold:

- `areEquivalent(a, a)` is always `true`. (Reflexivity)
- `areEquivalent(a, b)` implies `areEquivalent(b, a)`. (Symmetry)
- If `areEquivalent(a, b)` and `areEquivalent(b, c)` are both `true`, then
  `areEquivalent(a, c)` is also `true`. (Transitivity)

- Parameters:
  - other: A sequence to compare to this sequence.
  - areEquivalent: A predicate that returns `true` if its two arguments
    are equivalent; otherwise, `false`.
- Returns: `true` if this sequence and `other` contain equivalent items,
  using `areEquivalent` as the equivalence test; otherwise, `false.`

- Complexity: O(*m*), where *m* is the lesser of the length of the
  sequence and the length of `other`.

Returns a Boolean value indicating whether this sequence and another
sequence contain the same elements in the same order.

At least one of the sequences must be finite.

This example tests whether one countable range shares the same elements
as another countable range and an array.

    let a = 1...3
    let b = 1...10

    print(a.elementsEqual(b))
    // Prints "false"
    print(a.elementsEqual([1, 2, 3]))
    // Prints "true"

- Parameter other: A sequence to compare to this sequence.
- Returns: `true` if this sequence and `other` contain the same elements
  in the same order.

- Complexity: O(*m*), where *m* is the lesser of the length of the
  sequence and the length of `other`.

Returns a Boolean value indicating whether two values are equal.

Equality is the inverse of inequality. For any values `a` and `b`,
`a == b` implies that `a != b` is `false`.

- Parameters:
  - lhs: A value to compare.
  - rhs: Another value to compare.

Returns a closed range that contains both of its bounds.

Use the closed range operator (`...`) to create a closed range of any type
that conforms to the `Comparable` protocol. This example creates a
`ClosedRange<Character>` from "a" up to, and including, "z".

    let lowercase = "a"..."z"
    print(lowercase.contains("z"))
    // Prints "true"

- Parameters:
  - minimum: The lower bound for the range.
  - maximum: The upper bound for the range.

- Precondition: `minimum <= maximum`.

Returns a half-open range that contains its lower bound but not its upper
bound.

Use the half-open range operator (`..<`) to create a range of any type
that conforms to the `Comparable` protocol. This example creates a
`Range<Double>` from zero up to, but not including, 5.0.

    let lessThanFive = 0.0..<5.0
    print(lessThanFive.contains(3.14))  // Prints "true"
    print(lessThanFive.contains(5.0))   // Prints "false"

- Parameters:
  - minimum: The lower bound for the range.
  - maximum: The upper bound for the range.

- Precondition: `minimum <= maximum`.

Returns a partial range extending upward from a lower bound.

Use the postfix range operator (postfix `...`) to create a partial range
of any type that conforms to the `Comparable` protocol. This example
creates a `PartialRangeFrom<Double>` instance that includes any value
greater than or equal to `5.0`.

    let atLeastFive = 5.0...

    atLeastFive.contains(4.0)     // false
    atLeastFive.contains(5.0)     // true
    atLeastFive.contains(6.0)     // true

You can use this type of partial range of a collection's indices to
represent the range from the partial range's lower bound up to the end
of the collection.

    let numbers = [10, 20, 30, 40, 50, 60, 70]
    print(numbers[3...])
    // Prints "[40, 50, 60, 70]"

- Parameter minimum: The lower bound for the range.

- Precondition: `minimum` must compare equal to itself (i.e. cannot be NaN).

Returns a partial range up to, and including, its upper bound.

Use the prefix closed range operator (prefix `...`) to create a partial
range of any type that conforms to the `Comparable` protocol. This
example creates a `PartialRangeThrough<Double>` instance that includes
any value less than or equal to `5.0`.

    let throughFive = ...5.0

    throughFive.contains(4.0)     // true
    throughFive.contains(5.0)     // true
    throughFive.contains(6.0)     // false

You can use this type of partial range of a collection's indices to
represent the range from the start of the collection up to, and
including, the partial range's upper bound.

    let numbers = [10, 20, 30, 40, 50, 60, 70]
    print(numbers[...3])
    // Prints "[10, 20, 30, 40]"

- Parameter maximum: The upper bound for the range.

- Precondition: `maximum` must compare equal to itself (i.e. cannot be NaN).

Returns a partial range up to, but not including, its upper bound.

Use the prefix half-open range operator (prefix `..<`) to create a
partial range of any type that conforms to the `Comparable` protocol.
This example creates a `PartialRangeUpTo<Double>` instance that includes
any value less than `5.0`.

    let upToFive = ..<5.0

    upToFive.contains(3.14)       // true
    upToFive.contains(6.28)       // false
    upToFive.contains(5.0)        // false

You can use this type of partial range of a collection's indices to
represent the range from the start of the collection up to, but not
including, the partial range's upper bound.

    let numbers = [10, 20, 30, 40, 50, 60, 70]
    print(numbers[..<3])
    // Prints "[10, 20, 30]"

- Parameter maximum: The upper bound for the range.

- Precondition: `maximum` must compare equal to itself (i.e. cannot be NaN).

Returns a random element of the collection, using the given generator as
a source for randomness.

Call `randomElement(using:)` to select a random element from an array or
another collection when you are using a custom random number generator.
This example picks a name at random from an array:

    let names = ["Zoey", "Chloe", "Amani", "Amaia"]
    let randomName = names.randomElement(using: &myGenerator)!
    // randomName == "Amani"

- Parameter generator: The random number generator to use when choosing a
  random element.
- Returns: A random element from the collection. If the collection is
  empty, the method returns `nil`.

- Complexity: O(1) if the collection conforms to
  `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
  of the collection.
- Note: The algorithm used to select a random element may change in a
  future version of Swift. If you're passing a generator that results in
  the same sequence of elements each time you run your program, that
  sequence may change when your program is compiled using a different
  version of Swift.

Returns a random element of the collection.

Call `randomElement()` to select a random element from an array or
another collection. This example picks a name at random from an array:

    let names = ["Zoey", "Chloe", "Amani", "Amaia"]
    let randomName = names.randomElement()!
    // randomName == "Amani"

This method is equivalent to calling `randomElement(using:)`, passing in
the system's default random generator.

- Returns: A random element from the collection. If the collection is
  empty, the method returns `nil`.

- Complexity: O(1) if the collection conforms to
  `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
  of the collection.

Returns a sequence of pairs (*n*, *x*), where *n* represents a
consecutive integer starting at zero and *x* represents an element of
the sequence.

This example enumerates the characters of the string "Swift" and prints
each character along with its place in the string.

    for (n, c) in "Swift".enumerated() {
        print("\(n): '\(c)'")
    }
    // Prints "0: 'S'"
    // Prints "1: 'w'"
    // Prints "2: 'i'"
    // Prints "3: 'f'"
    // Prints "4: 't'"

When you enumerate a collection, the integer part of each pair is a counter
for the enumeration, but is not necessarily the index of the paired value.
These counters can be used as indices only in instances of zero-based,
integer-indexed collections, such as `Array` and `ContiguousArray`. For
other collections the counters may be out of range or of the wrong type
to use as an index. To iterate over the elements of a collection with its
indices, use the `zip(_:_:)` function.

This example iterates over the indices and elements of a set, building a
list consisting of indices of names with five or fewer letters.

    let names: Set = ["Sofia", "Camilla", "Martina", "Mateo", "Nicolás"]
    var shorterIndices: [Set<String>.Index] = []
    for (i, name) in zip(names.indices, names) {
        if name.count <= 5 {
            shorterIndices.append(i)
        }
    }

Now that the `shorterIndices` array holds the indices of the shorter
names in the `names` set, you can use those indices to access elements in
the set.

    for i in shorterIndices {
        print(names[i])
    }
    // Prints "Sofia"
    // Prints "Mateo"

- Returns: A sequence of pairs enumerating the sequence.

- Complexity: O(1)

Returns a subsequence by skipping elements while `predicate` returns
`true` and returning the remaining elements.

- Parameter predicate: A closure that takes an element of the
  sequence as its argument and returns `true` if the element should
  be skipped or `false` if it should be included. Once the predicate
  returns `false` it will not be called again.

- Complexity: O(*n*), where *n* is the length of the collection.

Returns a subsequence containing all but the given number of initial
elements.

If the number of elements to drop exceeds the number of elements in
the collection, the result is an empty subsequence.

    let numbers = [1, 2, 3, 4, 5]
    print(numbers.dropFirst(2))
    // Prints "[3, 4, 5]"
    print(numbers.dropFirst(10))
    // Prints "[]"

- Parameter k: The number of elements to drop from the beginning of
  the collection. `k` must be greater than or equal to zero.
- Returns: A subsequence starting after the specified number of
  elements.

- Complexity: O(1) if the collection conforms to
  `RandomAccessCollection`; otherwise, O(*k*), where *k* is the number of
  elements to drop from the beginning of the collection.

Returns a subsequence containing all but the specified number of final
elements.

If the number of elements to drop exceeds the number of elements in the
collection, the result is an empty subsequence.

    let numbers = [1, 2, 3, 4, 5]
    print(numbers.dropLast(2))
    // Prints "[1, 2, 3]"
    print(numbers.dropLast(10))
    // Prints "[]"

- Parameter k: The number of elements to drop off the end of the
  collection. `k` must be greater than or equal to zero.
- Returns: A subsequence that leaves off the specified number of elements
  at the end.

- Complexity: O(1) if the collection conforms to
  `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length of
  the collection.

Returns a subsequence containing the initial elements until `predicate`
returns `false` and skipping the remaining elements.

- Parameter predicate: A closure that takes an element of the
  sequence as its argument and returns `true` if the element should
  be included or `false` if it should be excluded. Once the predicate
  returns `false` it will not be called again.

- Complexity: O(*n*), where *n* is the length of the collection.

Returns a subsequence from the specified position to the end of the
collection.

The following example searches for the index of the number `40` in an
array of integers, and then prints the suffix of the array starting at
that index:

    let numbers = [10, 20, 30, 40, 50, 60]
    if let i = numbers.firstIndex(of: 40) {
        print(numbers.suffix(from: i))
    }
    // Prints "[40, 50, 60]"

Passing the collection's `endIndex` as the `start` parameter results in
an empty subsequence.

    print(numbers.suffix(from: numbers.endIndex))
    // Prints "[]"

Using the `suffix(from:)` method is equivalent to using a partial range
from the index as the collection's subscript. The subscript notation is
preferred over `suffix(from:)`.

    if let i = numbers.firstIndex(of: 40) {
        print(numbers[i...])
    }
    // Prints "[40, 50, 60]"

- Parameter start: The index at which to start the resulting subsequence.
  `start` must be a valid index of the collection.
- Returns: A subsequence starting at the `start` position.

- Complexity: O(1)

Returns a subsequence from the start of the collection through the
specified position.

The resulting subsequence *includes* the element at the position `end`. 
The following example searches for the index of the number `40` in an
array of integers, and then prints the prefix of the array up to, and
including, that index:

    let numbers = [10, 20, 30, 40, 50, 60]
    if let i = numbers.firstIndex(of: 40) {
        print(numbers.prefix(through: i))
    }
    // Prints "[10, 20, 30, 40]"

Using the `prefix(through:)` method is equivalent to using a partial
closed range as the collection's subscript. The subscript notation is
preferred over `prefix(through:)`.

    if let i = numbers.firstIndex(of: 40) {
        print(numbers[...i])
    }
    // Prints "[10, 20, 30, 40]"

- Parameter end: The index of the last element to include in the
  resulting subsequence. `end` must be a valid index of the collection
  that is not equal to the `endIndex` property.
- Returns: A subsequence up to, and including, the `end` position.

- Complexity: O(1)

Returns a subsequence from the start of the collection up to, but not
including, the specified position.

The resulting subsequence *does not include* the element at the position
`end`. The following example searches for the index of the number `40`
in an array of integers, and then prints the prefix of the array up to,
but not including, that index:

    let numbers = [10, 20, 30, 40, 50, 60]
    if let i = numbers.firstIndex(of: 40) {
        print(numbers.prefix(upTo: i))
    }
    // Prints "[10, 20, 30]"

Passing the collection's starting index as the `end` parameter results in
an empty subsequence.

    print(numbers.prefix(upTo: numbers.startIndex))
    // Prints "[]"

Using the `prefix(upTo:)` method is equivalent to using a partial
half-open range as the collection's subscript. The subscript notation is
preferred over `prefix(upTo:)`.

    if let i = numbers.firstIndex(of: 40) {
        print(numbers[..<i])
    }
    // Prints "[10, 20, 30]"

- Parameter end: The "past the end" index of the resulting subsequence.
  `end` must be a valid index of the collection.
- Returns: A subsequence up to, but not including, the `end` position.

- Complexity: O(1)

Returns a subsequence, up to the given maximum length, containing the
final elements of the collection.

If the maximum length exceeds the number of elements in the collection,
the result contains all the elements in the collection.

    let numbers = [1, 2, 3, 4, 5]
    print(numbers.suffix(2))
    // Prints "[4, 5]"
    print(numbers.suffix(10))
    // Prints "[1, 2, 3, 4, 5]"

- Parameter maxLength: The maximum number of elements to return. The
  value of `maxLength` must be greater than or equal to zero.
- Returns: A subsequence terminating at the end of the collection with at
  most `maxLength` elements.

- Complexity: O(1) if the collection conforms to
  `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length of
  the collection.

Returns a subsequence, up to the specified maximum length, containing
the initial elements of the collection.

If the maximum length exceeds the number of elements in the collection,
the result contains all the elements in the collection.

    let numbers = [1, 2, 3, 4, 5]
    print(numbers.prefix(2))
    // Prints "[1, 2]"
    print(numbers.prefix(10))
    // Prints "[1, 2, 3, 4, 5]"

- Parameter maxLength: The maximum number of elements to return.
  `maxLength` must be greater than or equal to zero.
- Returns: A subsequence starting at the beginning of this collection
  with at most `maxLength` elements.

- Complexity: O(1) if the collection conforms to
  `RandomAccessCollection`; otherwise, O(*k*), where *k* is the number of
  elements to select from the beginning of the collection.

Returns an array containing the concatenated results of calling the
given transformation with each element of this sequence.

Use this method to receive a single-level collection when your
transformation produces a sequence or collection for each element.

In this example, note the difference in the result of using `map` and
`flatMap` with a transformation that returns an array.

    let numbers = [1, 2, 3, 4]

    let mapped = numbers.map { Array(repeating: $0, count: $0) }
    // [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]

    let flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }
    // [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]

In fact, `s.flatMap(transform)`  is equivalent to
`Array(s.map(transform).joined())`.

- Parameter transform: A closure that accepts an element of this
  sequence as its argument and returns a sequence or collection.
- Returns: The resulting flattened array.

- Complexity: O(*m* + *n*), where *n* is the length of this sequence
  and *m* is the length of the result.

Returns an array containing the elements of this sequence in reverse
order.

The sequence must be finite.

- Returns: An array containing the elements of this sequence in
  reverse order.

- Complexity: O(*n*), where *n* is the length of the sequence.

Returns an array containing the non-`nil` results of calling the given
transformation with each element of this sequence.

Use this method to receive an array of non-optional values when your
transformation produces an optional value.

In this example, note the difference in the result of using `map` and
`compactMap` with a transformation that returns an optional `Int` value.

    let possibleNumbers = ["1", "2", "three", "///4///", "5"]

    let mapped: [Int?] = possibleNumbers.map { str in Int(str) }
    // [1, 2, nil, nil, 5]

    let compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }
    // [1, 2, 5]

- Parameter transform: A closure that accepts an element of this
  sequence as its argument and returns an optional value.
- Returns: An array of the non-`nil` results of calling `transform`
  with each element of the sequence.

- Complexity: O(*m* + *n*), where *n* is the length of this sequence
  and *m* is the length of the result.

Returns an array containing the results of mapping the given closure
over the sequence's elements.

In this example, `map` is used first to convert the names in the array
to lowercase strings and then to count their characters.

    let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    let lowercaseNames = cast.map { $0.lowercased() }
    // 'lowercaseNames' == ["vivien", "marlon", "kim", "karl"]
    let letterCounts = cast.map { $0.count }
    // 'letterCounts' == [6, 6, 3, 4]

- Parameter transform: A mapping closure. `transform` accepts an
  element of this sequence as its parameter and returns a transformed
  value of the same or of a different type.
- Returns: An array containing the transformed elements of this
  sequence.

Returns an array containing the results of mapping the given closure
over the sequence's elements.

In this example, `map` is used first to convert the names in the array
to lowercase strings and then to count their characters.

    let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    let lowercaseNames = cast.map { $0.lowercased() }
    // 'lowercaseNames' == ["vivien", "marlon", "kim", "karl"]
    let letterCounts = cast.map { $0.count }
    // 'letterCounts' == [6, 6, 3, 4]

- Parameter transform: A mapping closure. `transform` accepts an
  element of this sequence as its parameter and returns a transformed
  value of the same or of a different type.
- Returns: An array containing the transformed elements of this
  sequence.

- Complexity: O(*n*), where *n* is the length of the sequence.

Returns an array containing, in order, the elements of the sequence
that satisfy the given predicate.

In this example, `filter(_:)` is used to include only names shorter than
five characters.

    let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    let shortNames = cast.filter { $0.count < 5 }
    print(shortNames)
    // Prints "["Kim", "Karl"]"

- Parameter isIncluded: A closure that takes an element of the
  sequence as its argument and returns a Boolean value indicating
  whether the element should be included in the returned array.
- Returns: An array of the elements that `isIncluded` allowed.

- Complexity: O(*n*), where *n* is the length of the sequence.

Returns an index that is the specified distance from the given index,
unless that distance is beyond a given limiting index.

The following example obtains an index advanced four positions from a
string's starting index and then prints the character at that position.
The operation doesn't require going beyond the limiting `s.endIndex`
value, so it succeeds.

    let s = "Swift"
    if let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {
        print(s[i])
    }
    // Prints "t"

The next example attempts to retrieve an index six positions from
`s.startIndex` but fails, because that distance is beyond the index
passed as `limit`.

    let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)
    print(j)
    // Prints "nil"

The value passed as `distance` must not offset `i` beyond the bounds of
the collection, unless the index passed as `limit` prevents offsetting
beyond those bounds.

- Parameters:
  - i: A valid index of the collection.
  - distance: The distance to offset `i`. `distance` must not be negative
    unless the collection conforms to the `BidirectionalCollection`
    protocol.
  - limit: A valid index of the collection to use as a limit. If
    `distance > 0`, a limit that is less than `i` has no effect.
    Likewise, if `distance < 0`, a limit that is greater than `i` has no
    effect.
- Returns: An index offset by `distance` from the index `i`, unless that
  index would be beyond `limit` in the direction of movement. In that
  case, the method returns `nil`.

- Complexity: O(1) if the collection conforms to
  `RandomAccessCollection`; otherwise, O(*k*), where *k* is the absolute
  value of `distance`.

Returns an index that is the specified distance from the given index.

The following example obtains an index advanced four positions from a
string's starting index and then prints the character at that position.

    let s = "Swift"
    let i = s.index(s.startIndex, offsetBy: 4)
    print(s[i])
    // Prints "t"

The value passed as `distance` must not offset `i` beyond the bounds of
the collection.

- Parameters:
  - i: A valid index of the collection.
  - distance: The distance to offset `i`. `distance` must not be negative
    unless the collection conforms to the `BidirectionalCollection`
    protocol.
- Returns: An index offset by `distance` from the index `i`. If
  `distance` is positive, this is the same value as the result of
  `distance` calls to `index(after:)`. If `distance` is negative, this
  is the same value as the result of `abs(distance)` calls to
  `index(before:)`.

- Complexity: O(1) if the collection conforms to
  `RandomAccessCollection`; otherwise, O(*k*), where *k* is the absolute
  value of `distance`.

Returns an iterator over the elements of the collection.

Returns the distance between two indices.

Unless the collection conforms to the `BidirectionalCollection` protocol,
`start` must be less than or equal to `end`.

- Parameters:
  - start: A valid index of the collection.
  - end: Another valid index of the collection. If `end` is equal to
    `start`, the result is zero.
- Returns: The distance between `start` and `end`. The result can be
  negative only if the collection conforms to the
  `BidirectionalCollection` protocol.

- Complexity: O(1) if the collection conforms to
  `RandomAccessCollection`; otherwise, O(*k*), where *k* is the
  resulting distance.

Returns the elements of the sequence, shuffled using the given generator
as a source for randomness.

You use this method to randomize the elements of a sequence when you are
using a custom random number generator. For example, you can shuffle the
numbers between `0` and `9` by calling the `shuffled(using:)` method on
that range:

    let numbers = 0...9
    let shuffledNumbers = numbers.shuffled(using: &myGenerator)
    // shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]

- Parameter generator: The random number generator to use when shuffling
  the sequence.
- Returns: An array of this sequence's elements in a shuffled order.

- Complexity: O(*n*), where *n* is the length of the sequence.
- Note: The algorithm used to shuffle a sequence may change in a future
  version of Swift. If you're passing a generator that results in the
  same shuffled order each time you run your program, that sequence may
  change when your program is compiled using a different version of
  Swift.

Returns the elements of the sequence, shuffled.

For example, you can shuffle the numbers between `0` and `9` by calling
the `shuffled()` method on that range:

    let numbers = 0...9
    let shuffledNumbers = numbers.shuffled()
    // shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]

This method is equivalent to calling `shuffled(using:)`, passing in the
system's default random generator.

- Returns: A shuffled array of this sequence's elements.

- Complexity: O(*n*), where *n* is the length of the sequence.

Returns the elements of the sequence, sorted using the given predicate as
the comparison between elements.

When you want to sort a sequence of elements that don't conform to the
`Comparable` protocol, pass a predicate to this method that returns
`true` when the first element should be ordered before the second. The
elements of the resulting array are ordered according to the given
predicate.

In the following example, the predicate provides an ordering for an array
of a custom `HTTPResponse` type. The predicate orders errors before
successes and sorts the error responses by their error code.

    enum HTTPResponse {
        case ok
        case error(Int)
    }

    let responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]
    let sortedResponses = responses.sorted {
        switch ($0, $1) {
        // Order errors by code
        case let (.error(aCode), .error(bCode)):
            return aCode < bCode

        // All successes are equivalent, so none is before any other
        case (.ok, .ok): return false

        // Order errors before successes
        case (.error, .ok): return true
        case (.ok, .error): return false
        }
    }
    print(sortedResponses)
    // Prints "[.error(403), .error(404), .error(500), .ok, .ok]"

You also use this method to sort elements that conform to the
`Comparable` protocol in descending order. To sort your sequence in
descending order, pass the greater-than operator (`>`) as the
`areInIncreasingOrder` parameter.

    let students: Set = ["Kofi", "Abena", "Peter", "Kweku", "Akosua"]
    let descendingStudents = students.sorted(by: >)
    print(descendingStudents)
    // Prints "["Peter", "Kweku", "Kofi", "Akosua", "Abena"]"

Calling the related `sorted()` method is equivalent to calling this
method and passing the less-than operator (`<`) as the predicate.

    print(students.sorted())
    // Prints "["Abena", "Akosua", "Kofi", "Kweku", "Peter"]"
    print(students.sorted(by: <))
    // Prints "["Abena", "Akosua", "Kofi", "Kweku", "Peter"]"

The predicate must be a *strict weak ordering* over the elements. That
is, for any elements `a`, `b`, and `c`, the following conditions must
hold:

- `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)
- If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are
  both `true`, then `areInIncreasingOrder(a, c)` is also `true`.
  (Transitive comparability)
- Two elements are *incomparable* if neither is ordered before the other
  according to the predicate. If `a` and `b` are incomparable, and `b`
  and `c` are incomparable, then `a` and `c` are also incomparable.
  (Transitive incomparability)

The sorting algorithm is not guaranteed to be stable. A stable sort
preserves the relative order of elements for which
`areInIncreasingOrder` does not establish an order.

- Parameter areInIncreasingOrder: A predicate that returns `true` if its
  first argument should be ordered before its second argument;
  otherwise, `false`.
- Returns: A sorted array of the sequence's elements.

- Complexity: O(*n* log *n*), where *n* is the length of the sequence.

Returns the elements of the sequence, sorted.

You can sort any sequence of elements that conform to the `Comparable`
protocol by calling this method. Elements are sorted in ascending order.

Here's an example of sorting a list of students' names. Strings in Swift
conform to the `Comparable` protocol, so the names are sorted in
ascending order according to the less-than operator (`<`).

    let students: Set = ["Kofi", "Abena", "Peter", "Kweku", "Akosua"]
    let sortedStudents = students.sorted()
    print(sortedStudents)
    // Prints "["Abena", "Akosua", "Kofi", "Kweku", "Peter"]"

To sort the elements of your sequence in descending order, pass the
greater-than operator (`>`) to the `sorted(by:)` method.

    let descendingStudents = students.sorted(by: >)
    print(descendingStudents)
    // Prints "["Peter", "Kweku", "Kofi", "Akosua", "Abena"]"

The sorting algorithm is not guaranteed to be stable. A stable sort
preserves the relative order of elements that compare equal.

- Returns: A sorted array of the sequence's elements.

- Complexity: O(*n* log *n*), where *n* is the length of the sequence.

Returns the first element of the sequence that satisfies the given
predicate.

The following example uses the `first(where:)` method to find the first
negative number in an array of integers:

    let numbers = [3, 7, 4, -2, 9, -6, 10, 1]
    if let firstNegative = numbers.first(where: { $0 < 0 }) {
        print("The first negative number is \(firstNegative).")
    }
    // Prints "The first negative number is -2."

- Parameter predicate: A closure that takes an element of the sequence as
  its argument and returns a Boolean value indicating whether the
  element is a match.
- Returns: The first element of the sequence that satisfies `predicate`,
  or `nil` if there is no element that satisfies `predicate`.

- Complexity: O(*n*), where *n* is the length of the sequence.

Returns the first index in which an element of the collection satisfies
the given predicate.

You can use the predicate to find an element of a type that doesn't
conform to the `Equatable` protocol or to find an element that matches
particular criteria. Here's an example that finds a student name that
begins with the letter "A":

    let students = ["Kofi", "Abena", "Peter", "Kweku", "Akosua"]
    if let i = students.firstIndex(where: { $0.hasPrefix("A") }) {
        print("\(students[i]) starts with 'A'!")
    }
    // Prints "Abena starts with 'A'!"

- Parameter predicate: A closure that takes an element as its argument
  and returns a Boolean value that indicates whether the passed element
  represents a match.
- Returns: The index of the first element for which `predicate` returns
  `true`. If no elements in the collection satisfy the given predicate,
  returns `nil`.

- Complexity: O(*n*), where *n* is the length of the collection.

Returns the first index where the specified value appears in the
collection.

Returns the first index where the specified value appears in the
collection.

After using `firstIndex(of:)` to find the position of a particular element
in a collection, you can use it to access the element by subscripting.
This example shows how you can modify one of the names in an array of
students.

    var students = ["Ben", "Ivy", "Jordell", "Maxime"]
    if let i = students.firstIndex(of: "Maxime") {
        students[i] = "Max"
    }
    print(students)
    // Prints "["Ben", "Ivy", "Jordell", "Max"]"

- Parameter element: An element to search for in the collection.
- Returns: The first index where `element` is found. If `element` is not
  found in the collection, returns `nil`.

- Complexity: O(*n*), where *n* is the length of the collection.

Returns the longest possible subsequences of the collection, in order,
around elements equal to the given element.

The resulting array consists of at most `maxSplits + 1` subsequences.
Elements that are used to split the collection are not returned as part
of any subsequence.

The following examples show the effects of the `maxSplits` and
`omittingEmptySubsequences` parameters when splitting a string at each
space character (" "). The first use of `split` returns each word that
was originally separated by one or more spaces.

    let line = "BLANCHE:   I don't want realism. I want magic!"
    print(line.split(separator: " "))
    // Prints "["BLANCHE:", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"

The second example passes `1` for the `maxSplits` parameter, so the
original string is split just once, into two new strings.

    print(line.split(separator: " ", maxSplits: 1))
    // Prints "["BLANCHE:", "  I don\'t want realism. I want magic!"]"

The final example passes `false` for the `omittingEmptySubsequences`
parameter, so the returned array contains empty strings where spaces
were repeated.

    print(line.split(separator: " ", omittingEmptySubsequences: false))
    // Prints "["BLANCHE:", "", "", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"

- Parameters:
  - separator: The element that should be split upon.
  - maxSplits: The maximum number of times to split the collection, or
    one less than the number of subsequences to return. If
    `maxSplits + 1` subsequences are returned, the last one is a suffix
    of the original collection containing the remaining elements.
    `maxSplits` must be greater than or equal to zero. The default value
    is `Int.max`.
  - omittingEmptySubsequences: If `false`, an empty subsequence is
    returned in the result for each consecutive pair of `separator`
    elements in the collection and for each instance of `separator` at
    the start or end of the collection. If `true`, only nonempty
    subsequences are returned. The default value is `true`.
- Returns: An array of subsequences, split from this collection's
  elements.

- Complexity: O(*n*), where *n* is the length of the collection.

Returns the longest possible subsequences of the collection, in order,
that don't contain elements satisfying the given predicate.

The resulting array consists of at most `maxSplits + 1` subsequences.
Elements that are used to split the sequence are not returned as part of
any subsequence.

The following examples show the effects of the `maxSplits` and
`omittingEmptySubsequences` parameters when splitting a string using a
closure that matches spaces. The first use of `split` returns each word
that was originally separated by one or more spaces.

    let line = "BLANCHE:   I don't want realism. I want magic!"
    print(line.split(whereSeparator: { $0 == " " }))
    // Prints "["BLANCHE:", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"

The second example passes `1` for the `maxSplits` parameter, so the
original string is split just once, into two new strings.

    print(line.split(maxSplits: 1, whereSeparator: { $0 == " " }))
    // Prints "["BLANCHE:", "  I don\'t want realism. I want magic!"]"

The final example passes `false` for the `omittingEmptySubsequences`
parameter, so the returned array contains empty strings where spaces
were repeated.

    print(line.split(omittingEmptySubsequences: false, whereSeparator: { $0 == " " }))
    // Prints "["BLANCHE:", "", "", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"

- Parameters:
  - maxSplits: The maximum number of times to split the collection, or
    one less than the number of subsequences to return. If
    `maxSplits + 1` subsequences are returned, the last one is a suffix
    of the original collection containing the remaining elements.
    `maxSplits` must be greater than or equal to zero. The default value
    is `Int.max`.
  - omittingEmptySubsequences: If `false`, an empty subsequence is
    returned in the result for each pair of consecutive elements
    satisfying the `isSeparator` predicate and for each element at the
    start or end of the collection satisfying the `isSeparator`
    predicate. The default value is `true`.
  - isSeparator: A closure that takes an element as an argument and
    returns a Boolean value indicating whether the collection should be
    split at that element.
- Returns: An array of subsequences, split from this collection's
  elements.

- Complexity: O(*n*), where *n* is the length of the collection.

Returns the maximum element in the sequence, using the given predicate
as the comparison between elements.

The predicate must be a *strict weak ordering* over the elements. That
is, for any elements `a`, `b`, and `c`, the following conditions must
hold:

- `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)
- If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are
  both `true`, then `areInIncreasingOrder(a, c)` is also
  `true`. (Transitive comparability)
- Two elements are *incomparable* if neither is ordered before the other
  according to the predicate. If `a` and `b` are incomparable, and `b`
  and `c` are incomparable, then `a` and `c` are also incomparable.
  (Transitive incomparability)

This example shows how to use the `max(by:)` method on a
dictionary to find the key-value pair with the highest value.

    let hues = ["Heliotrope": 296, "Coral": 16, "Aquamarine": 156]
    let greatestHue = hues.max { a, b in a.value < b.value }
    print(greatestHue)
    // Prints "Optional((key: "Heliotrope", value: 296))"

- Parameter areInIncreasingOrder:  A predicate that returns `true` if its
  first argument should be ordered before its second argument;
  otherwise, `false`.
- Returns: The sequence's maximum element if the sequence is not empty;
  otherwise, `nil`.

- Complexity: O(*n*), where *n* is the length of the sequence.

Returns the maximum element in the sequence.

This example finds the largest value in an array of height measurements.

    let heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]
    let greatestHeight = heights.max()
    print(greatestHeight)
    // Prints "Optional(67.5)"

- Returns: The sequence's maximum element. If the sequence has no
  elements, returns `nil`.

- Complexity: O(*n*), where *n* is the length of the sequence.

Returns the minimum element in the sequence, using the given predicate as
the comparison between elements.

The predicate must be a *strict weak ordering* over the elements. That
is, for any elements `a`, `b`, and `c`, the following conditions must
hold:

- `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)
- If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are
  both `true`, then `areInIncreasingOrder(a, c)` is also
  `true`. (Transitive comparability)
- Two elements are *incomparable* if neither is ordered before the other
  according to the predicate. If `a` and `b` are incomparable, and `b`
  and `c` are incomparable, then `a` and `c` are also incomparable.
  (Transitive incomparability)

This example shows how to use the `min(by:)` method on a
dictionary to find the key-value pair with the lowest value.

    let hues = ["Heliotrope": 296, "Coral": 16, "Aquamarine": 156]
    let leastHue = hues.min { a, b in a.value < b.value }
    print(leastHue)
    // Prints "Optional((key: "Coral", value: 16))"

- Parameter areInIncreasingOrder: A predicate that returns `true`
  if its first argument should be ordered before its second
  argument; otherwise, `false`.
- Returns: The sequence's minimum element, according to
  `areInIncreasingOrder`. If the sequence has no elements, returns
  `nil`.

- Complexity: O(*n*), where *n* is the length of the sequence.

Returns the minimum element in the sequence.

This example finds the smallest value in an array of height measurements.

    let heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]
    let lowestHeight = heights.min()
    print(lowestHeight)
    // Prints "Optional(58.5)"

- Returns: The sequence's minimum element. If the sequence has no
  elements, returns `nil`.

- Complexity: O(*n*), where *n* is the length of the sequence.

Returns the position immediately after the given index.

The successor of an index must be well defined. For an index `i` into a
collection `c`, calling `c.index(after: i)` returns the same index every
time.

- Parameter i: A valid index of the collection. `i` must be less than
  `endIndex`.
- Returns: The index value immediately after `i`.

Returns the result of combining the elements of the sequence using the
given closure.

Use the `reduce(_:_:)` method to produce a single value from the elements
of an entire sequence. For example, you can use this method on an array
of numbers to find their sum or product.

The `nextPartialResult` closure is called sequentially with an
accumulating value initialized to `initialResult` and each element of
the sequence. This example shows how to find the sum of an array of
numbers.

    let numbers = [1, 2, 3, 4]
    let numberSum = numbers.reduce(0, { x, y in
        x + y
    })
    // numberSum == 10

When `numbers.reduce(_:_:)` is called, the following steps occur:

1. The `nextPartialResult` closure is called with `initialResult`---`0`
   in this case---and the first element of `numbers`, returning the sum:
   `1`.
2. The closure is called again repeatedly with the previous call's return
   value and each element of the sequence.
3. When the sequence is exhausted, the last value returned from the
   closure is returned to the caller.

If the sequence has no elements, `nextPartialResult` is never executed
and `initialResult` is the result of the call to `reduce(_:_:)`.

- Parameters:
  - initialResult: The value to use as the initial accumulating value.
    `initialResult` is passed to `nextPartialResult` the first time the
    closure is executed.
  - nextPartialResult: A closure that combines an accumulating value and
    an element of the sequence into a new accumulating value, to be used
    in the next call of the `nextPartialResult` closure or returned to
    the caller.
- Returns: The final accumulated value. If the sequence has no elements,
  the result is `initialResult`.

- Complexity: O(*n*), where *n* is the length of the sequence.

Returns the result of combining the elements of the sequence using the
given closure.

Use the `reduce(into:_:)` method to produce a single value from the
elements of an entire sequence. For example, you can use this method on an
array of integers to filter adjacent equal entries or count frequencies.

This method is preferred over `reduce(_:_:)` for efficiency when the
result is a copy-on-write type, for example an Array or a Dictionary.

The `updateAccumulatingResult` closure is called sequentially with a
mutable accumulating value initialized to `initialResult` and each element
of the sequence. This example shows how to build a dictionary of letter
frequencies of a string.

    let letters = "abracadabra"
    let letterCount = letters.reduce(into: [:]) { counts, letter in
        counts[letter, default: 0] += 1
    }
    // letterCount == ["a": 5, "b": 2, "r": 2, "c": 1, "d": 1]

When `letters.reduce(into:_:)` is called, the following steps occur:

1. The `updateAccumulatingResult` closure is called with the initial
   accumulating value---`[:]` in this case---and the first character of
   `letters`, modifying the accumulating value by setting `1` for the key
   `"a"`.
2. The closure is called again repeatedly with the updated accumulating
   value and each element of the sequence.
3. When the sequence is exhausted, the accumulating value is returned to
   the caller.

If the sequence has no elements, `updateAccumulatingResult` is never
executed and `initialResult` is the result of the call to
`reduce(into:_:)`.

- Parameters:
  - initialResult: The value to use as the initial accumulating value.
  - updateAccumulatingResult: A closure that updates the accumulating
    value with an element of the sequence.
- Returns: The final accumulated value. If the sequence has no elements,
  the result is `initialResult`.

- Complexity: O(*n*), where *n* is the length of the sequence.

The collection's "past the end" position---that is, the position one
greater than the last valid subscript argument.

When you need a range that includes the last element of a collection, use
the half-open range operator (`..<`) with `endIndex`. The `..<` operator
creates a range that doesn't include the upper bound, so it's always
safe to use with `endIndex`. For example:

    let numbers = [10, 20, 30, 40, 50]
    if let index = numbers.firstIndex(of: 30) {
        print(numbers[index ..< numbers.endIndex])
    }
    // Prints "[30, 40, 50]"

If the collection is empty, `endIndex` is equal to `startIndex`.

The corresponding value of the raw type.

A new instance initialized with `rawValue` will be equivalent to this
instance. For example:

    enum PaperSize: String {
        case A4, A5, Letter, Legal
    }

    let selectedSize = PaperSize.Letter
    print(selectedSize.rawValue)
    // Prints "Letter"

    print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
    // Prints "true"

The first element of the collection.

If the collection is empty, the value of this property is `nil`.

    let numbers = [10, 20, 30, 40, 50]
    if let firstNumber = numbers.first {
        print(firstNumber)
    }
    // Prints "10"

The indices that are valid for subscripting the collection, in ascending
order.

A collection's `indices` property can hold a strong reference to the
collection itself, causing the collection to be non-uniquely referenced.
If you mutate the collection while iterating over its indices, a strong
reference can cause an unexpected copy of the collection. To avoid the
unexpected copy, use the `index(after:)` method starting with
`startIndex` to produce indices instead.

    var c = MyFancyCollection([10, 20, 30, 40, 50])
    var i = c.startIndex
    while i != c.endIndex {
        c[i] /= 5
        i = c.index(after: i)
    }
    // c == MyFancyCollection([2, 4, 6, 8, 10])

The number of elements in the collection.

To check whether a collection is empty, use its `isEmpty` property
instead of comparing `count` to zero. Unless the collection guarantees
random-access performance, calculating `count` can be an O(*n*)
operation.

- Complexity: O(1) if the collection conforms to
  `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
  of the collection.

The position of the first element in a nonempty collection.

If the collection is empty, `startIndex` is equal to `endIndex`.

The raw type that can be used to represent all values of the conforming
type.

Every distinct value of the conforming type has a corresponding unique
value of the `RawValue` type, but there may be values of the `RawValue`
type that don't have a corresponding value of the conforming type.

These
are
several
line
comments
describing
the
operator.

This is a block comment describing the precedence group.